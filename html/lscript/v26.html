<HTML>

<SCRIPT LANGUAGE="JavaScript">
<!-- Begin
function openWindow(url)
{
    popupWin = window.open(url,'remote','scrollbars=yes,resizable=yes,width=800,height=600')
    popupWin.focus()
}

function openWebSite(url)
{
    popupWin = window.open(url)
    popupWin.focus()
}

//-->
</SCRIPT>

<HEAD>
<TITLE>LScript/LSIDE/Expressions Release Notes</TITLE>

</HEAD>

<BODY background="../ls_back2.gif"
      text="#ffffff"
      link="#ffffff"
      vlink="#ffffff">
</body>

<A NAME="TOP">
<CENTER>
<table border="1"
       cellpadding="3"
       cellspacing="0"
       bordercolor="#000000"
       bordercolorlight="#000000"
       width="600"
       bordercolordark="#FFFFFF">
  <tr>
    <td width=75 bgcolor="#001f00" align=center>
        <A HREF="#LSCRIPT">LScript</A>
    </td>
    <td width=75 bgcolor="#001f00" align=center>
        <A HREF="#LSIDE">LSIDE</A>
    </td>
    <td width=75 bgcolor="#001f00" align=center>
        <A HREF="#EXPRESS">Expressions</A>
    </td>
  </tr>
</table>

<br><br>

<A NAME="LSCRIPT">
<table border="1"
       cellpadding="3"
       cellspacing="0"
       bordercolor="#000000"
       bordercolorlight="#000000"
       width="600"
       bordercolordark="#FFFFFF">
  <tr>
    <td bgcolor="#c0c0c0">
<center><font size="+3" color="#000000">&nbsp;LScript v2.6 Release Notes&nbsp;</font></center>
    </td>
  </tr>
  <tr>
    <table border="1"
           cellpadding="3"
           cellspacing="0"
           bordercolor="#000000"
           bordercolorlight="#000000"
           width="600"
           bordercolordark="#FFFFFF">
      <tr>
        <td width=75 bgcolor="#001f00" align=center>
            <A HREF="#LSCRIPTFEATURES">Features</A>
        </td>
        <td width=75 bgcolor="#001f00" align=center>
            <A HREF="#LSCRIPTBEHAVIORS">Behaviors</A>
        </td>
        <td width=75 bgcolor="#001f00" align=center>
            <A HREF="#LSCRIPTBUGS">Bugs</A>
        </td>
      </tr>
    </table>
  </tr>
</table>

<br><br>

<A NAME="LSCRIPTFEATURES">
<table border="1"
       cellpadding="3"
       cellspacing="0"
       bordercolor="#000000"
       bordercolorlight="#000000"
       width="600"
       bordercolordark="#FFFFFF">
  <tr>
    <td bgcolor="#c0c0c0">
      <table border="0"
             cellpadding="3"
             cellspacing="0"
             bordercolor="#000000"
             bordercolorlight="#000000"
             width="600"
             bordercolordark="#FFFFFF">
        <tr>
          <td width=75 bgcolor="#c0c0c0" align=left>
<!--            <A HREF="#LSCRIPT">(lscript)</A> -->
          </td>
          <td width=75 bgcolor="#c0c0c0" align=center>
<font size="+2" color="#000000">&nbsp;New Features&nbsp;</font>
          </td>
          <td width=75 bgcolor="#c0c0c0" align=right>
            <A HREF="#TOP">(top)</A>
          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>

<table border="2"
       cellpadding="0"
       cellspacing="0"
       bordercolor="#000000"
       bordercolorlight="#000000"
       width="600"
       bordercolordark="#FFFFFF">
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                        
  C plug-ins can now take advantage of the LScript Universal Requester mechanism.
  This service, provided by the LCore subsystem, allows C plug-ins to use LScript's
  requester mechanism to create their user interfaces using LScript code.  This
  system allows C plug-ins to retrieve the result of the requester (i.e., whether
  "Ok" or "Cancel" was press), as well as set the initial control values and
  retrieve the resulting values when the requester is dismissed.

  The LScript code that implements the requester, written either by hand or
  generated by the LSIDE Interface Designer, is stored in a NULL-terminated array
  of character strings.  This array is then passed to the Universal Requester
  mechanism for compilation:

<font color="#0000A0">            const char *ui_script[] = {
                                        "options",
                                        "{",
                                            "reqbegin(\"LScript Universal Requester test\");",

                                            "c1 = ctlnumber(\"Number\",lsur_num);",

                                            "if(reqpost())",
                                                "lsur_num = getvalue(c1);",

                                            "reqend();",
                                        "}",
                                        NULL
                                      };
            ...

            int             err,ok;
            char            *messages[10];
            LSURFuncs       *lsurFunc;
            LWLSURID        script;

            double          lsur_num;
            void            *vars[1];

            lsurFunc = (*global)(LWLSUR_GLOBAL,GFUSE_TRANSIENT);

            script = (*lsurFunc->compile)(ui_script,messages,10);</font>

  The Universal Requester mechanism will compile the provided script code, and
  return an opaque pointer that represents the compiled code.  If there were
  problems with your script code, any messages generated during the compile will
  be placed into the provided receptical.  If they exist, these messages should
  be processed and freed afterward:

<font color="#0000A0">            ...
            for(x = 0,err = 0;x < 10;x++)
            {
                if(!messages[x]) break;

                if(!strncmp(messages[x],"e#",2))
                {
                    ++err;
                    (*msgFuncs->error)(&messages[x][2],"");
                }

                free(messages[x]);
            }

            if(err) return(AFUNC_OK);
            ...</font>

  Messages generated will be prefixed with a meta-code that indicates their
  severity.  Informational messages will be prefixed by "i#", warning messages by
  "w#", and errors by "e#".  If errors occurred during the compile, you should
  gracefully exit (the returned script pointer will be NULL in any case).

  The Universal Requester mechanism takes care of making sure your initial values
  are where they should be, as well as seeing that the resulting values are returned
  to you.  In order to accomplish this, however, there are some design requirements
  that must be adhered to.

    1.  controls must be initialized with variables in order to have data exchange
        occur between the C plug-in and the LScript code.
    2.  variables used for data exchange must be prefixed with the letters "lsur_"
        (see the above code example)
    3.  a call to getvalue() must be made on a specific variable in order to retrieve
        the resulting control value for that specific variable back into the appropriate
        receptical in the C plug-in

  A list of (void *) are provided to the Universal Requester mechanism in order to
  provide both initial values and a location to receive the result.  Each (void *)
  should point to a variable type appropriate to the control with which it is
  associated.  For instance, a ctlnumber() pointer should point to a (double) value.

<font color="#0000A0">            ...
            lsur_num = 34.54;

            vars[0] = (void *)&lsur_num;

            ok = (*lsurFunc->post)(script,vars);
            ...</font>

  When the requester is dismissed, any variables that have had an explicit getvalue()
  call assigned to them will be automtically updated in the C plug-in.

<font color="#0000A0">            ...
            if(ok)
            {
                // user pressed "Ok", and values have been updated
                ...
            }
            ...</font>

  Values can be changed again and the requester re-posted as many times as necessary.
  When you are through with your requester, it should be passed to the release
  function to free up the memory it consumes.

<font color="#0000A0">            ...
            ok = (*lsurFunc->post)(script,vars);
            (*lsurFunc->release)(script);

            if(ok)
            {
            ...</font>

  Any control type supported by LScript can be used in the requester, however, only
  the following control types are supported for data exchange:

        (char *)
            ctlstring()
            ctltext()
            ctlfilename()
            ctlimage()
            ctlsurface()
            ctlfont()

        (integer)
            ctlinteger()
            ctlchoice()
            ctlpopup()
            ctlcheckbox()
            ctlslider()
            ctlminislider()
            ctlstate()

        (double)
            ctlnumber()
            ctldistance()
            ctlpercent()
            ctlangle()

        (double[3])
            ctlvector()
            ctlcolor()
            ctlrgb()
            ctlhsv()

        (LWItemID)
            ctlallitems()
            ctlmeshitems()
            ctlboneitems()
            ctlcameraitems()
            ctllightitems()

        (LWImageID)
            ctlimageitems()

        (LWChannelID)
            ctlchannel()
      <center>
        <table border=1>
          <tr>
            <td bgcolor="#FFFFFF">
            <img src="pointer.png" align=absmiddle>
            </td>
            <td bgcolor="#505050">
              <font color="#FFFFFF">
              <pre>
  The header file required to use this mechanism (lwlcore.h) can be
  found in the LightWave 7.5b SDK distribution.  Also included in the  
  SDK is a sample project, called "lsur", that illustrates the usage
  of the LScript Universal Requester mechanism.
              </pre>
              </font>
            </td>
          </tr>
        </table>
      </center>
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  A <b>keys()</b> method can be applied to an associative array to extract all keys contained
  within the array.  This allows a script to access all data elements contained in the
  associative array in a linear fashion.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  A <b>contains()</b> methods is now available for integral data types that will, given a data
  type and value, search through indexable types (arrays, strings, etc.) to determine if
  that type and value exists.  It returns a Boolean true/false value to indicate the
  presence or absence, respectively, of the provided value.

<font color="#0000A0">        ...
        str = "Now is the time";
        info(str.contains("is the"));   // displays true (1)
        info(str.contains("Bob"));      // displays false (0)
        ...

        ...
        t = @15.87,"Blowfish",<1,9,0.5>@;
        info(t.contains(<1,9,0.5>));    // displays true (1)
        info(t.contains(15.87));        // displays true (1)
        info(t.contains("Blow"));       // displays false (0)
        ...</font>
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  LScripts now have additional modes of saving that can be selected using the new <b>@save</b>
  pragma.  The <b>original</b> mode stores the full path name of the script into the scene or
  object file.  This mode is the default, and does not have to be explicitly selected.

  Scripts can also be saved in <b>relative</b> mode.  This saves only the name of the script
  in the scene or object file.  Upon reload, a script with that name should exist in the
  default LScript directory \NewTek\LScripts.  This is handy for situations like batch
  rendering, allowing scripts to be flexibly relocated.

  Lastly, scripts can be directly <b>embedded</b> within, and carried along with, the scene or
  object file.  This ensures that the script will always be available no matter where the
  file goes, or when or where it is reloaded.

<font color="#ffff00">        @save   original
        @save   relative
        @save   embedded</font>

  To employ these settings, the script must first be activated from a disc file.  Subsequent
  saving and loading of scene or object files will permanently maintain these settings.
  Scripts must be deactivated and the scene or object re-saved to disable the storage mode.
      <center>
        <table border=1>
          <tr>
            <td bgcolor="#FFFFFF">
            <img src="pointer.png" align=absmiddle>
            </td>
            <td bgcolor="#c0c0c0">
              <font color="#000000">
              <pre>
  <b>Debugging should not be attempted with embedded scripts</b>.   
  Debug your scripts first before you activate this saving
  mode.
              </pre>
              </font>
            </td>
          </tr>
        </table>
      </center>
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  A new control type called <b>ctlviewport()</b> is available to script requesters.  This control
  is similar to ctlinfo(), however, it functions as a viewport into a larger canvass area.
  The canvass can be much larger than the viewport window, and can be navigated using
  included vertical and horizontal scroll bars.

  The arguments to ctlviewport() are identical to that of ctlinfo(), save for an additional
  callback that reports the dimensions of the virtual canvass.  This size function will always
  be called immediately before the redraw function, so you can dynamically resize the canvass
  to fit the situation.

<font color="#0000A0">        c1 = ctlviewport(200,200,"vp_redraw",<b>"vp_size"</b>);</font>

  This size callback should return the width and height of the canvass upon which the
  viewport (whose size is set in the initial function call) will traverse.  The size function
  could, for instance, return a fixed size or it could calculate the bounding area of objects
  positioned upon the canvass.  It accepts the control identifier to which the dimensions should
  apply.

<font color="#0000A0">        vp_size: ctl
        {
            return(800,600);
        }</font>

  Drawing on the canvass should be performed without regard to viewport size.  Your drawing
  function should behave as though the user can see the entire canvass at once.  It accepts the
  control identifier for which drawing functions will apply.

<font color="#0000A0">        vp_redraw: ctl
        {
            drawbox(<80,80,80>,0,0,800,600);

            drawbox(<200,200,200>,50,50,20,20);
            drawbox(<0,200,0>,750,450,20,20);
        }</font>

  In addition, the Control Object Agent class now exports two new data members called <b>xoffset</b>
  and <b>yoffset</b>.  These data members are currently a constant zero (0) for all types except for
  the viewport control.  The values in these data members contain the current X (left) and Y
  (top) offsets of the control's viewport.  These values can be used to accurately calculate
  things such as the virtual location of mouse events on the canvass.

<font color="#0000A0">        reqmousedown: mouse_x, mouse_y, ctrl
        {
            x = mouse_x - ctrl.x + ctrl.xoffset;
            y = mouse_y - ctrl.y + ctrl.yoffset;
            ...
        }</font>

  Or they can be assigned values to position the viewport at a specific location on the
  virtual canvass.  The range of allowable values runs from zero (0) to
  (<b>canvass_width - viewport_width</b>) on the horizontal, and zero (0) to
  (<b>canvass_height - viewport_height</b>) on the vertical.  LScript will automatically clamp
  assigned values to these ranges if you exceed them.

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  The Requester mechanism now provides four new primitive drawing functions, <b>drawcircle()</b>,
  <b>drawelipse()</b>, <b>drawfillcircle()</b> and <b>drawfillelipse()</b>.  As their names imply, the first two draw
  unfilled circular shapes, while the latter two draw filled circular shapes, on the panel or in
  any other valid drawing region (e.g., ctlviewport()).

  <b>drawcircle()</b> takes four arguments, being (1) color, (2) X center point, (3) Y center point,
  and (4) radius.  <b>drawfillcircle()</b> takes five, (1) border color, (2) fill color, (3) X center
  point, (4) Y center point, and (5) radius.  All numeric values are interpreted as integers.

  <b>drawelipse()</b> takes five arguments, being (1) color, (2) X center point, (3) Y center point,
  (4) X radius, and (5) Y radius.  <b>drawfillelipse()</b> takes six, (1) border color, (2) fill color,
  (3) X center point, (4) Y center point, (5) X radius, and (6) Y radius.  All numeric values are
  interpreted as integers.

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  A Requester panel's position can now be set and queried using the new <b>reqposition()</b> command.
  The command takes two optional arguments that specify the screen X and Y position for the
  panel.  These values can be set at anytime between reqbegin() and reqend().  If the panel is
  open on the screen when the call is made, the panel's position is immediately altered.

  Whether called with or without arguments, <b>reqposition()</b> will return the current position of the
  panel at the time the call is made.  This makes it possible for a script to perform its own
  between-runs management of the panel's position on the screen (LScript does this automatically
  since v2.5, but there are only a limited number of panels it will remember).

<font color="#0000A0">        generic
        {
            reqbegin("Position Test");
            ...
            req_x = recall("req_x",0);
            req_y = recall("req_y",0);
            reqposition(req_x,req_y);
            ...
            return if !reqpost();
            ...
            (x,y) = reqposition();
            store("req_x",x);
            store("req_y",y);

            reqend();
            ...
        }</font>

  Because <b>reqposition()</b> will immediately update an open panel, on-screen positioning can be
  performed in real time:

<font color="#0000A0">        req_x,req_y;

        generic
        {
            reqbegin("Position Test");
            ...
            return if !reqpost("idle",500);
            ...
            reqend();
            ...
        }

        idle
        {
            ++req_x;
            ++req_y;
            reqposition(req_x,req_y);
        }</font>

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  New I/O functions are available to the I/O Object Agent passed to the save() and load()
  pre-defined script functions.  These new methods provide finer granularity when dealing
  with numeric data types in OBJECT I/O mode.

  <b>readDouble()</b> will pull in a <b>double</b>-sized numeric value (typically eight bytes) from the
  source file.  <b>writeDouble()</b> will store a numeric value of the same size.  The existing
  <b>readNumber()</b>/<b>writeNumber()</b> methods continue to perform their operations using the
  <b>float</b>-sized numeric value.

  <b>readShort()</b>/<b>writeShort()</b> will work with short-sized numeric values (typically two bytes).
  The <b>readInt()</b>/<b>writeInt()</b> functions continue to work with integer-sized values (typically
  four bytes).

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  New File Object Agent methods are available that provide finer granularity when dealing
  with integral numeric data types.

  <b>readDouble()</b> will pull in a <b>double</b>-sized numeric value (typically eight bytes) from the
  source file.  <b>writeDouble()</b> will store a numeric value of the same size.  The existing
  <b>readNumber()</b>/<b>writeNumber()</b> methods will perform their operations using the
  <b>float</b>-sized numeric value.

  <b>readShort()</b>/<b>writeShort()</b> will work with short-sized numeric values (typically two bytes).
  The <b>readInt()</b>/<b>writeInt()</b> functions continue to work with integer-sized values (typically
  four bytes).
      <center>
        <table border=1>
          <tr>
            <td bgcolor="#FFFFFF">
            <img src="pointer.png" align=absmiddle>
            </td>
            <td bgcolor="#505050">
    <font color="#FFFFFF">
    <pre>
  Please see the note in the <a href="#FILEARGS">Behavioral Changes</a> section regarding  
  the new, optional argument that all File Object Agent binary-mode  
  methods accept for managing byte ordering.
    </pre>
    </font>
            </td>
          </tr>
        </table>
      </center>
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  The currently selected Weight, Texture or Morph vertex map can now be acquired in Modeler by
  providing an index value of zero (0) to the <b>VMap()</b> constructor when specifying one of the three
  vertex map types:

<font color="#ffff00">        vmap = VMap(VMWEIGHT,0) || error("Select a Weight map so I have something to do!");</font>

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  A new Layout function is available called <b>visitnodes()</b>.  This function attempts to simplify
  the process of iterating down through object parenting hierarchies.

  The function requires two arguments.  The first argument is an Object Agent reference
  for an object type capable of containing children--Mesh, Light, Camera or Bone.
  
  The second argument is a character string that identifies a UDF in the script that will be
  called by LScript for each child object found in the hierarchy.  The UDF must accept two
  arguments, the parent Object Agent and the child Object Agent.  Be aware that multiple calls
  may be made with the same parent identity if that parent manages more than one child.

<font color="#0000A0">        generic
        {
            visitnodes(Mesh("MasterObject"),"process_node");
        }

        process_node: parent, child
        {
            info(parent.name," -> ",child.name);
        }</font>

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  A new Layout Object Agent method called <b>keyExists()</b> can be used to identify all of an object's
  channels that contain a keyframe at an indicated time index.  Each channel that contains a
  keyframe at the indicated time will be returned by the method.

<font color="#ffff00">        generic
        {
            if((channels = Mesh("Null").keyExists(2.0)) != nil)
            {
                foreach(c,channels)
                    info("Null." + c.name);
            }
        }</font>

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  A <b>binary()</b> function is now available that will convert integer values into their binary
  equivalents in string form.  The function takes an integer value, and an optional size
  value (whose maximum on any platform is [sizeof(int) * 8] bits).  The function will remove
  leading zeros, unless an explict number of bits are indicated:

<font color="#0000A0">        generic
        {
            info(binary(32));       // displays "100000"
            info(binary(32,32));    // displays "00000000000000000000000000100000"
            info(binary(130,8));    // displays "10000010"
            info(binary(130,10));   // displays "0010000010"
        }</font>

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  A new Object Agent class has been defined in LScript called a Glyph.  This class is a container
  for color images, whose intended purpose is to act as color icons that can be drawn into display
  contexts such as the Requester redraw, ctlinfo() and ctlviewport().

  Glyphs can be constructed from a disc file by providing the filename as argument to the Glyph
  constructor.  Alternately, the name of an embedded binary block can also be specified as the
  source of the image data:

<font color="#ffff00">        ...
        cursor_img = Glyph(cursorGlyph);
        ...
        @data cursorGlyph 500
        000 000 002 000 000 000 000 000 000 000 000 000 012 000 012 000 024 000 080 080
        ...</font>

  A 'nil' is returned if the glyph construction fails for some reason.

  The Glyph Object Agent currently exports no public methods.  The following public data members
  are available:

        w               the width of the glyph image (read-only)

        h               the height of the glyph image (read-only)

        pixel[col,row]  array of pixel color data for the glyph image
                        (write-only in default mode, read-write in dual-mode)

  Once constructed, the glyph can be drawn into display contexts using the new <b>drawglyph()</b>
  function.  This function takes the Glyph Object Agent, along with the X and Y position
  within the context where the glyph should be drawn:

<font color="#ffff00">        ...
        // draw the cursor glyph
        drawglyph(cursor_img,
                  cursor_pos.x - integer(cursor_img.w / 2),
                  cursor_pos.y - integer(cursor_img.h / 2));
        ...</font>

  Two additional arguments, both optional, can be provided to the Glyph() constructor.  By default,
  Glyphs are generated in a way that allows them to be drawn to the display context with the
  utmost speed.  What is traded for such drawing speed is the ability to directly access individual
  pixels in the image.  The second argument you can provide to the Glyph() constructor is a
  Boolean flag that tells LScript that you'll need pixel-based access to the image data in the
  Glyph (dual-mode).  You'll need to specify this mode, for instance, when you plan to overlay the
  Glyph onto Image Filter data (Image Filter data is not a valid display context, so the high-speed
  form of the Glyph cannot be directly drawn onto it).

  The third optional argument is a transparency color mask to be used when drawing the Glyph.
  Because the use of such a mask requires per-pixel access to the image data, specifying a
  transparency mask automatically enables this mode in the Glyph object.

  Because Glyph image data can be of any type supported by any Image Loader plug-in active in
  the host application (see notes regarding this in the <a href="#IMAGELOAD">Behavioral Changes</a> section), you may
  need to specify a file-type hint when you embed the image data into your script via a binary
  block.  By default, LScript will append the extension ".tga" to image data in a binary block
  before attempting to process it.  Sometimes this will work with non-Targa image data, and
  sometimes it won't.  Your file-type hint should take the form of the appropriate file
  extension, and be appended to the name of the binary block, separated by an underscore
  character.

<font color="#ffff00">        @data cursorGlyph_jpg 500
        000 000 002 000 000 000 000 000 000 000 000 000 012 000 012 000 024 000 080 080
        080 080 080 080 080 080 080 080 080 080 080 080 080 080 080 080 080 080 080 080
        ...
        085 069 086 073 083 073 079 078 045 088 070 073 076 069 046 000 
        @end</font>

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  Variables local to a user-defined function can now be made static (i.e., their values persist
  across invocations of the function) by prefacing the name of the variable with the characters
  "st_".

<font color="#0000A0">        generic
        {
            for(x = 0;x < 5;x++)
                docount();
        }

        docount
        {
            if(!st_value)
                st_value = 0;

            info(++st_value);
        }</font>

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  Five new Command Sequence functions have been added to Modeler LScript:

        <b>revert([&lt;filename&gt;])</b>

            Causes the current object to revert to the mesh stored in the specified disc
            file.  If no file is provided, LScript attempts to revert using the object file's
            current filename (of course, if the file hasn't been saved yet, an error will
            result).

        <b>selectvmap(&lt;type&gt;,&lt;name&gt;)</b>

            Selects the specified VMap type and name for editing.  The <b>&lt;type&gt;</b> can only be
            one of Morph, Spot, Weight, Subpatch weight or Texture UV.  These types can be
            specified using the same type values provided to the VMap() Object Agent
            Constructor.

        <b>meshedit(&lt;name&gt;)</b>

            Invokes a MeshEdit plug-in of the specified name.

        <b>smoothscale(&lt;distance&gt;)</b>

            Performs a Smooth Scale operation on the selected mesh, offsetting the
            mesh by the specified <b>&lt;distance&gt;</b>.

        <b>changepart(&lt;name&gt;)</b>

            (Re)assigns the part name of the currently selected polygons.

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  The Mesh Object Agent exports two new public methods:

        <b>layerName(&lt;layernum&gt;)</b>

            Returns the assigned name for the specified layer of the object.  If the layer
            has yet to be assigned a name, then the method returns 'nil'.

        <b>layerVisible(&lt;layernum&gt;)</b>

            Returns a Boolean true or false to indicate the visible state of the indicated
            layer.

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  New character classification methods have been added to the system.  Each of these methods maps
  directly to their ANSI C counterparts, and can be applied to integer values, or string values
  where only the first character in the string will be regarded.

  None of the methods accept arguments, and each returns a Boolean true/false value.

        <b>isPrint()</b>

            Test the character for printability.

        <b>isAlpha()</b>

            Test the character for membership in the alphabetic class (i.e., a-z or A-Z).

        <b>isAlnum()</b>

            Test the character for membership in the alpha-numeric class.

        <b>isAscii()</b>

            Test the character for membership in the ASCII character set.

        <b>isCntrl()</b>

            Test the character for membership in the control code character set.

        <b>isDigit()</b>

            Test the character for membership in the numeric character set (i.e., 0-9).

        <b>isPunct()</b>

            Test the character for membership in the punctuation character set
            (i.e., any printable character that is not a space character, or a character
            for which isAlnum() returns true).

        <b>isSpace()</b>

            Test the character as whitespace (i.e., a space character, or character in the
            range 0x09–0x0D).

        <b>isUpper()</b>

            Test the character for membership in the upper-case alphabetic character set.

        <b>isLower()</b>

            Test the character for membership in the lower-case alphabetic character set.

        <b>isXDigit()</b>

            Test the character for membership in the hexidecimal character set (i.e.,
            one of "0123456789ABCDEF").

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  The existing LScript <b>log()</b> function calculates the natural logarithm (base-<i>e</i>) of the provided
  value.  This can be a bit misleading for those seeking base-10 functionality, so a new function
  has been added, <b>log10()</b>, to address this.

<font color="#0000A0">        generic
        {
            x = log(23);
            y = log10(23);
            z = log(23) / log(10);  // same as log10(23)
        }</font>

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  The LScript language has a new power operator, "^^".  This operator can be used directly in the
  the language as a substitute for the pow() function.

<font color="#ffff00">        t = 5^^2;       // 25
        i = 10;
        info(i ^^ 3);   // displays 1000</font>
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  Image Filter LScripts can use a new function called <b>overlayglyph()</b> to blend a Glyph Object
  Agent onto the image data cache.  This function takes a Glyph Object Agent reference and an
  X and Y offset position where the Glyph will be stamped onto the image cache.  An optional
  fourth argument allows the Glyph image to be composited onto the image cache with a
  transparency (alpha) value, ranging from 0.0, which renders the Glyph without transparency
  (the default value), to 1.0, which renders the Glyph with 100% transparency (the Glyph will
  not be visible).

<font color="#0000A0">        bug;

        create
        {
            bug = Glyph(vt4000,true);
            setdesc("Bug");
        }

        process: width, height, frame, starttime, endtime
        {
            overlayglyph(bug,1,1);
            overlayglyph(bug,1,height - bug.h,0.25);
            overlayglyph(bug,width - bug.w,height - bug.h,0.5);
            overlayglyph(bug,width - bug.w,1,0.75);
            overlayglyph(bug,(width - bug.w) / 2,(height - bug.h) / 2,0.25);
        }

        @data vt4000 67800
        000 000 002 000 000 000 000 000 000 000 000 000 188 000 120 000 024 000 026 026
        026 025 025 025 025 025 025 025 025 025 026 026 026 026 026 026 025 025 025 025
        ...
        000 000 000 000 000 000 084 082 085 069 086 073 083 073 079 078 045 088 070 073
        076 069 046 000 
        @end</font>

The result:

<center><image src="v26_1.jpg"></center>
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  Channel Object Agents now provide a data member called <b>parent</b> that contains the LightWave
  Object Agent to whom the channel belongs.

</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  The Scene Object Agent's <b>generalopts[]</b> array now has a seventh [7] array element that
  indicates the current state of the "Auto Key" button on the interface -- Boolean true
  for "on", and Boolean false for "off".

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  The Scene Object Agent now provides the following additional data members:

        <b>alertlevel</b>

            indicates the state of the Alert Level setting in Layout.  Will be one of
            ALERT_BEGINNER, ALERT_INTERMEDIATE or ALERT_EXPERT.

        <b>boxthreshold</b>

            an integer value indicating the current bounding-box threshold setting.

        <b>autokeycreate</b>

            indicates the state of the Alert Key Create setting in Layout.  Will be
            one of AKC_OFF, AKC_MODIFIED or AKC_ALL.

        <b>numthreads</b>

            the number of threads that will be spawned during rendering.

        <b>animfilename</b>

            the name of the currently selected animation file.  'nil' if none.

        <b>rgbprefix</b>

            the name of the RGB file-saving prefix.  'nil' if none.

        <b>alphaprefix</b>

            the name of the Alpha channel file-saving prefix.  'nil' if none.

</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  LightWave Object Agents now export an array called <b>axislocks[]</b>.  This array contains
  nine elements, where each triplet corresponds to the object's Position, Rotation and
  Scaling channels.  Each triplet element corresponds to the appropriate axis for the
  transformational category, and is a Boolean value that indicates the lock status of
  that particular channel/axis element (true == locked).

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  An Icon Object Agent has been added to LScript.  This object type is designed to construct
  and house a bitmapped pattern of pixels.  These pattern of pixels represent a complete user-
  defined text character (or "dingbat").  Icon characters are active only during an active
  Requester panel.

  The maximum dimension of each character is 16 pixels wide by 14 tall.  Characters are defined
  by placing character strings into an array.  The width of each character string should not
  exceed the maximum width, while the number of strings in each array should not exceed the
  maximum height.  In each character string a period character ('.') indicates a zero-pixel
  value (off), while any non-period character will represent a one-pixel value (on).  Each array
  is provided to the Icon() constructor for construction and storage of the monochrome character
  image.

<font color="#ffff00">        folder_icon = @ "..1111..........",
                        ".1....111111....",
                        ".1..........1...",
                        ".1..........1...",
                        ".1...1111111111.",
                        ".1..1..........1",
                        ".1.1..........1.",
                        ".11..........1..",
                        ".111111111111..."
                      @;


        eyes_icon = @ "................",
                      "................",
                      "...mmm...mmm....",
                      "......m.m.......",
                      "....mm...mm.....",
                      "...m..m.m..m....",
                      "..m.mm.m.mm.m...",
                      "..m.m..m.m..m...",
                      "..m....m....m...",
                      "...m..m.m..m....",
                      "....mm...mm.....",
                      "................",
                      "................"
                    @;

        @define FOLDER      1
        @define EYES        2

        generic
        {
            icon[FOLDER] = Icon(folder_icon);
            icon[EYES] = Icon(eyes_icon);

            reqbegin("Testing Icons");

            c1 = ctlbutton("Open File " + icon[FOLDER],75,"bfunc1");
            c2 = ctlstring(icon[EYES].asStr() + " Browse","testing");

            reqpost();
        }

        bfunc1
        {
            ...
        }</font>

  Icons can then be embedded in any character string that will be processed and displayed by
  LScript (button or control label text, listbox entries, etc.).

<br><center><image src="v26_4.jpg"></center>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  In addition to <b>SCHEMA</b>, the Custom Object <b>flags()</b> function can now also return the
  following values:

        <b>VPINDEX</b>

            indicates that the value in the <b>view</b> data member should correspond to
            the viewport number instead of its type.

        <b>NODEPTH</b>

            causes drawing of the object to occur in front of all other OpenGL elements,
            regardless of Z position.

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  The <b>getdir()</b> command now recognizes the <b>SCRIPTSDIR</b> constant, or the "scripts" string, and
  will return a path that points to the NewTek\LScripts installation directory on the local
  system.

</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  A <b>getsep()</b> function has been added that will return the platform-specific path separator
  character.

<font color="#0000A0">        ...
        info(getsep());     // displays "\", "/" or ":" depending on the operating system
        ...</font>

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  The Displacement Access Object Agent, provided to the <b>process()</b> function of Displacement
  LScripts, now exports a <b>point</b> data member.  This data member holds a Point Object Agent
  for the mesh point currently being processed.

</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  LScript now provides support for hexidecimal-formatted numbers. These numbers are prefixed by
  the "0x" character sequence, and can contain 1-8 hexidecimal digits (A-F, a-f, 0-9).

<font color="#0000A0">        ...
        t = 5 * 0xa0;       // equivalent to 5 * 160
        ...</font>

  In addition, the <b>integer()</b> function has been enhanced to recognize and process hexidecimal
  numbers in string form.

<font color="#0000A0">        ...
        t = integer("0x0a");                        // t will hold 10
        t = integer("Now is the 0xF000 time");      // t will hold 61440
        ...</font>

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  LScript now provides support for binary-formatted numbers. These numbers are prefixed by the
  "0b" character sequence, and can contain 1-32 binary digits (0 or 1).

<font color="#ffff00">        ...
        t = 0b1001;         // t holds 9
        ...</font>

  In addition, the <b>integer()</b> function has been enhanced to recognize and process binary
  numbers in string form.

<font color="#ffff00">        ...
        t = integer("0b110");                       // t will hold 6
        t = integer("Now is the 0b10000 time");     // t will hold 16
        ...</font>

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  A new function called <b>lscriptVersion()</b> returns information about the version of the LScript
  system that is executing the script.  It returns four elements in this order:  a string
  representation of the LScript version (identical to that displayed by LScript in the title
  bar of the script-select file dialog); the major component of the version as an integer;
  the minor component of the version as an integer; the patch level of the version as an
  integer.

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  The Layout LScript Compiler provides a new mode for generating compiled scripts.  This new
  compiled type is a "library", and is intended to be a collection of functions (potentially
  unrelated) that are not associated with any single plug-in architecture.  Once compiled, this
  "library" script can be used by any LScript through the use of the library command.

  Functions defined within the "library" file can be referenced from a script as though they
  were built into LScript.

<font color="#ffff00">        @version 2.6
        @warnings
        @script generic

        // the 'functions.lsc' library contains the gimmeStringFrom() function

        library "functions.lsc";   // no path, so file should be in \NewTek\LScripts

        generic
        {
            t = 104;
            info(gimmeStringFrom(t));
        }</font>

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  A new callback named <b>reqkeyboard()</b> can be defined to intercept keyboard activity on the active
  Requester panel.  This function takes a single argument which represents the raw key pressed.
  It should return a Boolean false or true value indicating that the key should or should not be
  further processed by the system, respectively.

<font color="#0000A0">        @version 2.6
        @warnings
        @script generic

        generic
        {
            reqbegin("Testing reqkeyboard()");

            c1 = ctlstring("String","value");

            if(reqpost())
                info("You pressed Ok");
            else
                info("You pressed Cancel");

            reqend();
        }

        reqkeyboard: key
        {
            if(key == 13)       // enter
            {
                reqabort(true);
                return(true);
            }
            else if(key == 27)  // escape
            {
                reqabort();
                return(true);
            }

            return(false);
        }</font>

  The following pre-defined constants have been added to the environment in order to help process
  key events:
<font color="#003000">
        REQKB_F1                REQKB_KB0               REQKB_KP0
        REQKB_F2                REQKB_KB1               REQKB_KP1
        REQKB_F3                REQKB_KB2               REQKB_KP2
        REQKB_F4                REQKB_KB3               REQKB_KP3
        REQKB_F5                REQKB_KB4               REQKB_KP4
        REQKB_F6                REQKB_KB5               REQKB_KP5
        REQKB_F7                REQKB_KB6               REQKB_KP6
        REQKB_F8                REQKB_KB7               REQKB_KP7
        REQKB_F9                REQKB_KB8               REQKB_KP8
        REQKB_F10               REQKB_KB9               REQKB_KP9
        REQKB_F11
        REQKB_F12               REQKB_ALT               REQKB_RETURN
                                REQKB_SHIFT             REQKB_INSERT
        REQKB_LEFT              REQKB_CTRL              REQKB_HOME
        REQKB_RIGHT                                     REQKB_END
        REQKB_UP                REQKB_DELETE            REQKB_PAGEUP
        REQKB_DOWN              REQKB_HELP              REQKB_PAGEDOWN
</font>
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  A new indexOf() method can be applied to string, linear array and binary block data types.  This
  method can be used to locate data within these indexable types.  The method returns the index
  where the specified data is found.  If it is not found, then a value of zero (0) is returned.

  In the case of character strings, the provided search value is treated as a displayable character:

<font color="#ffff00">        ...
        s = "val1:15:3.14";
        ndx = s.indexOf(':');   // returns 5
        ...</font>

  For linear arrays, the value provided must match an element in both type and value in order
  to be considered a successful match.  Not all data types are supported for searching.

  Searches through binary data will treat the provided integer value as an unsigned character,
  and should be in the range 0 to 255.

  By default, searches begin at the initial index offset of one (1).  You can specify a beginning
  offset other than one by providing the integer offset before the search value.

<font color="#ffff00">        ...
        s = "val1:15:3.14";
        ndx = s.indexOf(':');           // returns 5
        ndx = s.indexOf(ndx + 1,':');   // returns 8
        ...</font>

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  The Surface Object Agent's <b>getValue()</b> method now has a companion method called <b>setValue()</b>.  By
  providing the channel name and an appropriate value, the value of the Surface's channel can be
  altered.  

<font color="#0000A0">        ...
        (obj) = Scene().getSelect();
        (firstsrf) = Surface(obj);
        srf = Surface(firstsrf);

        srf.setValue(SURFCOLR,<0,255,255>);

        translucency = srf.getValue(SURFTRNL);
        srf.setValue(SURFTRNL,translucency * 2);
        ...</font>

  All channels supported by <b>getValue()</b> can be altered using <b>setValue()</b> <i>except for</i> those involving
  Image Object Agents.

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  The LScript pre-processor recognizes a new compile-time pragma named <b>@sequence</b>.  This pragma
  allows you to define a collection of names whose values are sequential increments.  This pragma
  type is similar to the C enum function.

  A collection of sequence names is enclosed with open and close braces:

<font color="#ffff00">        ...
        @sequence  { ... }
        ...</font>

  Names in the collection are separated from one another by commas:

<font color="#ffff00">        ...
        @sequence  { VIEWPORT_CTL, COPY_CTL, PASTE_CTL }
        ...</font>

  Like lines of binary data, entries in the sequence collection can span multiple lines:

<font color="#ffff00">        ...
        @sequence  { VIEWPORT_CTL,
                     COPY_CTL,
                     PASTE_CTL }
        ...</font>

  By default, sequences begin at one (1) and increment by one thereafter.  That is, in the example
  above, <b>VIEWPORT_CTL</b> would have the value 1, <b>COPY_CTL</b> would equate to 2, and so on.  The sequence
  value can be overridden at any point by assigning a new sequence value to a collection entry:

<font color="#ffff00">        ...
        @sequence  { VIEWPORT_CTL,
                     COPY_CTL = 5,
                     PASTE_CTL }
        ...</font>

  In this case, <b>VIEWPORT_CTL</b> would still have the value of 1, but <b>COPY_CTL</b> would have the value
  5 and <b>PASTE_CTL</b> would be assigned the value 6.

  An increment value can also be specified by separating the sequence value from the new increment
  value using a colon:

<font color="#ffff00">        ...
        @sequence  { VIEWPORT_CTL = 1:2,
                     COPY_CTL,
                     PASTE_CTL }
        ...</font>

  With this code, <b>VIEWPORT_CTL</b> would still have the value of 1, but <b>COPY_CTL</b> would have the value
  3 and <b>PASTE_CTL</b> would equate to 5.

  Once declared, you can use these sequence entries anyplace in your script you would otherwise
  use a <b>@define</b>'d value.

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  The <b>ctlbutton()</b> function now accepts an optional fourth parameter that constitutes an argument
  list that will be passed to the button's designated callback function.  This argument list is
  wrapped in quotation marks (i.e., passed as a string), and contains one or more argument values
  each separated by a comma.

<font color="0000A0">        ...
        reqbegin("Testing");
        c1 = ctlbutton("press me",70,"press_me","10,r1,r2");
        reqpost();
        ...</font>

  The arguments indicated can be of a constant value (numeric or character string, with the
  latter enclosed in double quotation marks), or they can be variable name references that
  are either global or local to the function that invoked ctlbutton().

<font color="0000A0">        r1 = "bob";

        generic
        {
            r2 = "hood";

            reqbegin("Testing");
            c1 = ctlbutton("press me",70,"press_me","10,r1,r2");
            reqpost();
            reqend();
        }

        press_me: arg1, arg2, arg3
        {
            info(arg1," ",arg2," ",arg3);
        }</font>

</font>
</pre>
    </td>
  </tr>
</table>

<br><br><br>

<A NAME="LSCRIPTBEHAVIORS">
<table border="1"
       cellpadding="3"
       cellspacing="0"
       bordercolor="#000000"
       bordercolorlight="#000000"
       width="600"
       bordercolordark="#FFFFFF">
  <tr>
    <td bgcolor="#c0c0c0">
      <table border="0"
             cellpadding="3"
             cellspacing="0"
             bordercolor="#000000"
             bordercolorlight="#000000"
             width="600"
             bordercolordark="#FFFFFF">
        <tr>
          <td width=75 bgcolor="#c0c0c0" align=left>
            <A HREF="#LSCRIPT">(lscript)</A>
          </td>
          <td width=75 bgcolor="#c0c0c0" align=center>
<font size="+2" color="#000000">&nbsp;Behavioral Changes&nbsp;</font>
          </td>
          <td width=75 bgcolor="#c0c0c0" align=right>
            <A HREF="#TOP">(top)</A>
          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>

<table border="2"
       cellpadding="0"
       cellspacing="0"
       bordercolor="#000000"
       bordercolorlight="#000000"
       width="600"
       bordercolordark="#FFFFFF">
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  LScript's execution mechanism has been re-engineered to remove all global contexts.
  A script's context is now passed from function to function as is the standard for LightWave
  plug-ins.

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  Due to the redesign of LScript's execution mechanism, the interface for User-Defined
  Object Agents and DLL functions has been altered to include an opaque context pointer
  in the LSFunc structure.  This opaque pointer must be included in all calls to LScirpt
  functions defined within that structure.  The interface version has been increased
  as a result to 1.4, and all new Object Agent or DLL development must return this
  value to LScript to ensure the correct structure pointer is provided to callbacks.

  Existing binary Object Agent or DLL files should continue to function with LScript at
  the previous (1.3) interface version, although it is highly recommended that the
  Object Agent code be updated for the v1.4 interface, if possible.  The v1.3 interface
  is no longer governed by the LScript memory manager.
      <center>
        <table border=1>
          <tr>
            <td bgcolor="#FFFFFF">
            <img src="pointer.png" align=absmiddle>
            </td>
            <td bgcolor="#c0c0c0">
              <font color="#000000">
              <pre>
  The new LScript header file can be found in the include directory  
  of the LightWave 7.5b SDK distribution, and is now called
  "lwlscript.h".
              </pre>
              </font>
            </td>
          </tr>
        </table>
      </center>
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  The LScript Debugger's variable watch system has been redesigned.  The current function's
  arguments and local variables are now automatically displayed in the watch window as long
  as the function is active.  As each new function is entered (or returned to), it's variables
  replace those of the previous function.  This behavior is more consistent with popular
  debuggers.  Informational displays have also been greatly enhanced.

<center><image src="v26_2.jpg"></center>

<center><image src="v26_3.jpg"></center>

  Global variables are not automatically added to the watch window.  In order to add global
  variables to the watch, you must now highlight the variable name in the script by double-
  clicking with the left mouse button, and then select "Add Watch" from the Debug menu (or
  press the F3) key.  If the selected text matches the name of a global variable in the script,
  it will be added to the watch window and will remain in the watch window as you move in and
  out of functions.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  The Modeler new() command, upon success, now returns a Mesh Object Agent for the new
  object created.

<font color="#ffff00">        main
        {
            m1 = Mesh(0);
            info(m1.id);

            m2 = new();
            if(!m2.isInt())
                info(m2.id);
        }</font>
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  The Mesh() constructor now returns 'nil' for an index value that is out of range instead
  of generating an error message and halting execution of the script.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  LScript now automatically updates any persistent Object Agent references (i.e., stored in
  variables or arrays anywhere in the script) with new object id's whenever they are
  altered by Layout.  This action occurs transparently, with no script intervention required.

  It can result in some disconcerting behavior in your script unless you program with an
  awareness that it can occur.  For example, a script that stores Mesh Object Agents in an
  array for processing might look like the following:

<font color="#ffff00">    ...
    curObj = Mesh();
    while(curObj)
    {
        objList[++x] = curObj;
        curObj = curObj.next();
    }
    ...</font>

  Later in the script, a particular object whose Agent is stored in the array is cleared
  from the Layout scene using the ClearSelected() Command Sequence function:

<font color="#ffff00">    ...
    objList[2].select();
    ClearSelected();
    ...</font>

  When ClearSelected() is called, Layout removes the selected object from the scene.  This
  action typically causes a chain reaction in the current scene that alters all the internal
  identifiers of the remaining objects.  This event is now handled by LScript transparently.
  However, you can see the result by looking at the array contents before the deletion:

<center><image src="v26_5.jpg"></center>

  and then after:

<center><image src="v26_6.jpg"></center>

  Notice that it looks as though the array itself has been altered by the change in the
  scene.  In actual fact, the underlying object identifiers of each Mesh Object Agent
  have been updated, and their (new) corresponding object names now appear (in this case,
  in the debugger watch window).

  The fifth element in the array, which referenced the "(5)" Null object in the scene, now
  identifies itself as "(none)".  This is an indication that the object identifier it
  contains is no longer valid in the current scene.

  You should be aware of actions in your script that might generate such behaviors if you
  have stored Object Agents of this type.  From the example above, if you are deleting
  objects from the scene based upon Object Agents stored in an array, you need to avoid
  order dependency in the code that processes the array.

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  The Mouse functions now take a single Object Agent argument that wraps all available parameters
  into a single package.  This Object Agent exports the following data members:

        ctl         the Control Object Agent involved in the event ('nil' if none)
        x           X position of the event
        y           Y position of the event
        button      which mouse button triggered the event; 1=LMB, 2=MMB, 3=RMB
        count       the click count; 1=single-click, 2=double-click
        keys[3]     indicates key active modifiers; [1]=CTRL, [2]=SHIFT, [3]=ALT

  The Object Agent currently exports no public methods.

<font color="#0000A0">        ...
        reqmousemove: md
        {
            if(md.ctl)
            {
                vp_x = md.x - md.ctl.x + md.ctl.xoffset;
                ...</font>
      <center>
        <table border=1>
          <tr>
            <td bgcolor="#FFFFFF">
            <img src="pointer.png" align=absmiddle>
            </td>
            <td bgcolor="#505050">
              <font color="#FFFFFF">
              <pre>
  This change will cause problems for compiled LScripts that use the  
  old form of the mouse-handling functions.  These scripts <b><i>must be
  updated and recompiled</i></b> in order to function correctly with
  this release of LScript.
              </pre>
              </font>
            </td>
          </tr>
        </table>
      </center>
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<A NAME="FILEARGS">
<pre>
<font color="#FFFFFF">
                                                                                                    
  The File Object Agent methods that deal with binary file modes now accept an optional Boolean
  argument that indicates whether or not the read numeric value should have its byte ordering
  swapped.  By default, byte ordering will remain as it was read in from the file.  Passing a
  Boolean true will cause the byte ordering to be swapped before the value is returned.

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  The constant <b>LINUX</b> has been added to the environment, and will be returned by functions like
  platform().  It can also be tested for using the pre-processor's conditional build @if system.
  Any tests against this value that are true indicate that the script is running under the Linux
  version of Screamernet (i.e., runningUnder() is guaranteed to return <b>SCREAMERNET</b>).

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  The pre-processor now performs multi-pass processing on the script in order to deal with
  situations such as pragma directives appearing in multi-line comments:

<font color="#ffff00">       /*
       @define FOO  100
       @autoerror
       */</font>

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<A NAME="IMAGELOAD">
<pre>
<font color="#000000">
                                                                                                    
  Image-loading activities, such as those performed by ctlimage() or Glyph(), now channel through
  any Image I/O plug-ins that might be active in the host application (Layout or Modeler).  This
  means that a much broader range of image file formats can now be processed besides just Targa.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  The ctlimage() function now returns a 'nil' value if the attempt to load an indicated image file
  fails.  This will usually be an indication that the required ImageLoader plug-in has not been
  installed into the application (an error message will still be displayed to the user if the
  indicated image file simply doesn't exist).  Scripts using non-Targa image files should check
  this return value to ensure that the control was properly created.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  The ChannelGroup() constructor now accepts two ChannelGroup Object Agents as arguments.  Passing
  one will return the first sub-group found under the specified channel group, however, two are
  needed in order to iterate through all sub-groups found under a specified channel group.  The
  second ChannelGroup Object Agent is considered the "current" channel, and any sub-group defined
  following it will be returned (or 'nil', if no further sub-groups exist).
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  The setvalue() function now first attempts to match a list value for ctlpopup() controls if a
  string value is provided.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  In order to be able to process discontinuous UV values, several of the VMap Object Agent's
  methods have had their argument lists augmented.

        isMapped(<font color="0000A0">&lt;point&gt;</font>[,<font color="0000A0">&lt;polygon&gt;</font>])

            isMapped() now accepts an optional second argument which should be the
            polygon for which the discontinuous UV values for the indicated point
            should be checked.

        getValue(<font color="0000A0">&lt;point&gt;</font>[,<font color="0000A0">&lt;polygon&gt;</font>][,<font color="0000A0">&lt;index&gt;</font>])

            getValue() processes a second argument that indicates the polygon for
            which discontinuous UV values should be retrieved.  an <font color="0000A0">&lt;index&gt;</font> value can
            also be specified to limit the retrieval to a specific value index.

        setValue(<font color="0000A0">&lt;point&gt;</font>,<font color="0000A0">&lt;value&gt;</font>|<font color="0000A0">&lt;array&gt;</font>[,<font color="0000A0">&lt;polygon&gt;</font>][,<font color="0000A0">&lt;index&gt;</font>])     <b>(MODELER ONLY)</b>

            a <font color="0000A0">&lt;polygon&gt;</font> can now be included in the setValue() argument list to allow
            values to be assigned to a polygon's per-vertex (discontinuous) UV.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  The loadimage() and clearimage() functions are now global, and can be used in either Layout or
  Modeler.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  The Mesh(), Camera(), Light() and Image() constructors have had their scanning code enhanced.
  When an object name is provided, these constructors will match the first object found with that
  name, regardless of alphabetic case.  However, if two or more objects of that type exist in the
  system with the same name, then one must match the name provided exactly in order for a sucessful
  match to occur.

  For example, an object called "Cow.lwo" is loaded into the application.  The following code will
  successfully match that object:

<font color="0000A0">
        ...
        obj = Mesh("cow");
        ...</font>

  However, subsequently an object called "COW.lwo" is loaded, leaving "Cow" and "COW" in the
  application.  The previous code would fail (returning 'nil'), and must be altered to
  unambiguously match one of the loaded objects:

<font color="0000A0">
        ...
        obj = Mesh("Cow");
        ...</font>

  Object names returned to the script by the application will contain their respective case
  settings, and so should always match the correct objects when used.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  All pragma directives must now begin in the first column of the row in order to be
  recognized.  This is to remove confusion when an initblock token ('@') appears
  as the first character on the line (at a column other than the first).
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  The <b>ctlslider()</b> function now accepts an optional fifth integer argument that can
  be used to specify the absolute width of the slider component of the control.  This
  width is independent of the range of the slider itself.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  The LScript Debugger's watch and message windows can now be interactively resized.  By clicking
  and dragging in the empty area just above either of these windows, you can resize the viewable
  area to within some predefined limits.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  The <b>count()</b> method can now be provided a character argument when applied to string-type
  objects.  When provided, the number of occurances of that character will be returned
  to the caller as an integer.

<font color="0000A0">        ...
        s = "1:2:5:38";
        info(s.count(':'));   // displays 3
        ...</font>
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  The <b>asStr()</b> method can now be applied to linear arrays.  Supported data types will be
  concatenated into a single string value.  Elements of 'nil' value are ignored.  You can
  provide an optional character value that will be used to separate values added to the
  string.

<font color="#ffff00">        ...
        a[1] = "val1";
        a[2] = 15;
        a[3] = nil;
        a[4] = 3.14;
        info(a.asStr(':'));     // displays "val1:15:3.14"
        ...</font>
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  The CommandInput() function has been enabled for use in Modeler LScripts.  It can be used
  to invoke any CommandSequence functions specific to Modeler or common to both applications
  that have not specifically been addressed within LScript.

<font color="0000A0">        ...
        CommandInput("Surf_SetWindowPos 100 50");
        ...</font>

  You should continue to use any available LScript-specific functions that map to CommandSequence
  functions to provide argument type and value checking within your script.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  The compiler now correctly recognizes and processes numeric values in scientific
  notation without the need for trailing decimal values.

<font color="#ffff00">        ...
        val = 2e2;
        ...</font>
</font>
</pre>
    </td>
  </tr>
</table>

<br><br><br>

<A NAME="LSCRIPTBUGS">
<table border="1"
       cellpadding="3"
       cellspacing="0"
       bordercolor="#000000"
       bordercolorlight="#000000"
       width="600"
       bordercolordark="#FFFFFF">
  <tr>
    <td bgcolor="#c0c0c0">
      <table border="0"
             cellpadding="3"
             cellspacing="0"
             bordercolor="#000000"
             bordercolorlight="#000000"
             width="600"
             bordercolordark="#FFFFFF">
        <tr>
          <td width=75 bgcolor="#c0c0c0" align=left>
            <A HREF="#LSCRIPT">(lscript)</A>
          </td>
          <td width=75 bgcolor="#c0c0c0" align=center>
<font size="+2" color="#000000">&nbsp;Bug Fixes&nbsp;</font>
          </td>
          <td width=75 bgcolor="#c0c0c0" align=right>
            <A HREF="#TOP">(top)</A>
          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>

<table border="2"
       cellpadding="0"
       cellspacing="0"
       bordercolor="#000000"
       bordercolorlight="#000000"
       width="600"
       bordercolordark="#FFFFFF">
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                        
  Due to the re-design of the execution mechanism, Procedural Texture LScript's can now
  function properly when rendering is performed with multiple threads.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                        
  If the <b>Mesh(0)</b> constructor call was made on an unsaved object, it would return an
  Agent for an object in the workspace that had been saved to disc already.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                          
  The <b>Mesh(0)</b> call was activating code that caused invalid indexing to occur under
  Layout.  When problems arose, they most often manifested as the incorrect object
  being proxied.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                        
  The <b>requpdate()</b> function was not refreshing the panel when no arguments were
  provided.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                        
  The <b>setvalue()</b> function was not correctly accepting empty string values.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                          
  Functions that did not return a value as expected could wreak havoc with LScript's
  internal stack, causing a crash if they were used directly in comparisons, e.g.:

<font color="#ffff00">         if(NotDone() == true)
            ...

         NotDone
         {
             if(x == 0)
                 return(true);

             // nothing returned on this path...
         }</font>
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                        
  The <b>server()</b> method contained an inverted state test that prevented it from returning
  anything but 'nil'.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                          
  The Modeler <b>makecone()</b> command was incorrectly converting floating-point arguments
  into integers.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                        
  <b>ctlinfo()</b> controls were not being correctly rendered when they were attached to tab
  pages.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                          
  <b>SelectItem()</b> was not properly processing bone name references.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                        
  Pre- and post-increment and pre- and post-decrement operators were not functioning
  properly when applied directly to array elements.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                          
  Pragma directives inside comments were not being properly ignored by the pre-processor.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                        
  The <b>setvalue()</b> and <b>getvalue()</b> functions were not working properly with Tab controls.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                          
  The <b>foreach()</b> operator would not process any Object Agent type except Mesh.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                        
  The <b>foreach()</b> operator would not recognize Layout Object Agents in an array
  provided for processing.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                          
  The <b>filecopy()</b> function contained a nasty bug that would destroy the contents of
  the source file.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                        
  A rare case could occur with the <b>foreach()</b> operator where the variable used for the
  iteration could retain a memory pointer that was subsequently reused by LScript's
  memory manager for assignment to another variable.  This situation could lead to a
  crash when a function's local memory was reclaimed by the garbage collector -- the
  cross-link situation would clear two variables when one was released, leaving the
  second in an undefined state when it too was reclaimed.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                          
  Several constants defining the type of a Light were missing from the environment.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                        
  The <b>points[]</b> data member of the Polygon Object Agent was not being correctly bound
  to its object type, and as a result, was inaccessible.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                          
  The measurements of the <b>getWorldRotation()</b> method were not being correctly converted
  into degrees before return to the script.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                        
  The <b>ShadowColor()</b> function did not have the correct number of arguments defined.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                          
  When a whole number was used to initialized a <b>ctlangle()</b> control, the control value
  would only increase regardless of which direction the scroller was dragged.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                        
  A memory overrun could occur in the Requester's panel position mechanism when all
  available slots were filled.  Panel positions are aged, with the oldest being
  replaced by the current Requester, but the actual position in the list was not being
  used.  This overrun could manifest, among other ways, as a crash of the application
  when the mouse pointer entered the Requester panel.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                          
  A control event ocurring in a modal Requester that had spawned another modal
  Requester could cause LScript to become confused as to which was the currently
  active panel.  This typically manifests as the child panel being inaccessible,
  and crashes possible with mouse activity.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                        
  The Scene <b>fogColor()</b> method was assigning all color values to the vector X element.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                          
  The <b>ctlchannel()</b> code had a subtle problem that prevented it from correctly
  locating the specified initial channel in the listbox.  This left things in
  an unstable state, leading to crashing on subsequent invocations.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                        
  File line counting was not accurate when the last line did not contain a newline
  sequence.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                          
  Queue Object Agents were not being properly reclaimed by LScript's garbage collector,
  potentially leading to unsocial behavior (crash or lockup).
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                        
  The <b>split()</b> function would cause a memory overrun whenever the drive component of
  the provided path was loinger than about eight characters.  Since PC drive designators
  are almost always only two characters, this problem manifested more readily on the
  Mac.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                          
  Several Command Sequence functions (like TargetItem() and ParentItem()) failed to consider
  bones as valid targets.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                        
  Corrected a problem with setting listbox selections using the <b>setvalue()</b> function.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                          
  Corrected a problem with listbox updates and the <b>requpdate()</b> function.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                        
  Ownership of a Particle System Object Agent was not explicity identified in the system,
  leading to destruction of the Object Agent (and to the underlying particle system) when
  a variable that had attached to it was reclaimed by the garbage collector.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                          
  The <b>meshedit()</b> function was calling the SelectVMap command.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                        
  Requester separators were not erasing properly.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                          
  The <b>ctlactive()</b> function was not handling all elements of a compound control.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                        
  The @insert mechanism was not functioning correctly using the standard C file handling
  functions.  The pre-processor has been redesigned to process inserts in memory instead.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                          
  The LScript debugger was not capturing script messages correctly.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                        
  The LScript debugger was crashing upon exit due to some poor handling of the watch and
  message window entries.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                          
  The Requester mouse functions were not covering the entire client area of the panel
  when the mode was non-modal.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                        
  The LScript configuration module, responsible for managing data from functions like
  <b>store()</b> and <b>recall()</b>, contained some potential ambiguity problems in its use of the
  C strncmp() function when scanning for keys.  This potential problem only affected
  non-Windows platforms.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                          
  The internal mechanism responsible for duplication of an active script (engaged
  in cases where you clone an item with a script enabled, for instance) was based on
  some fairly archaic code.  The means by which it performed the copy operation would
  often leave the original script at risk of destruction, and would never really
  activate the script on the new item.

  The new mechanism will correctly activate the source script on the target item.  It
  will also copy certain global values from the original script into the corresponding
  values in the new activation.  Due to their complexity, certain data types, such as
  Binary Blocks and internal Object Agents, are not duplicated in the target script.

  The copy of values occurs only <i>after</i> the script is activated on the duplicated
  object, and its <b>create()</b> function has successfully completed.  This may have some odd
  effects on your script, most obviously where the <b>setdesc()</b> function is concerned.
  If you call <b>setdesc()</b> in your <b>create()</b> function, the duplicated script may end up
  displaying values to the user that are not valid after the value copy has completed.

  In order to combat this problem, LScript will look for a pre-defined function called
  <b>cloned()</b> in the duplicated script.  This function, if it exists, will be invoked by
  LScript immediately following the duplication of global values from the original
  script.  The <b>cloned()</b> function takes no aguments, and should return no values.

  Activities involving data changes within your script should be centralized within this
  function.  For instance, you could place a single call to <b>setdesc()</b> in this function,
  and then invoke the function whereever appropriate from within your script:

<font color="#ffff00">        ...
        create
        {
            ...
            cloned();       // after initial operational values are established
        }

        cloned
        {
            // data values have changed...
            setdesc("...");
        }

        options
        {
            ...
            cloned();       // after user has changed operational values
        }
        ...</font>
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                        
  The <b>setvalue()</b> function was not completely simulating user interaction with a control,
  so not all defined callbacks were being invoked when a control's value was changed
  programmatically.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                          
  Vector and distance controls were not evenly sizing their input fields when modified
  using <b>ctlposition()</b>.  Each now allocates the specified control width, less the
  width of the control's label, evenly among their three input fields.  In order to ensure
  their integrity, the widths of each are now clamped when they fall below a pre-defined
  minimum.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                        
  Usage of the <b>previewstart</b>, <b>previewend</b>, and <b>previewstep</b> data members while running under
  Screamernet would cause a crash.  These values, associated with an interface that doesn't
  exist under the network renderer, are now mapped to <b>renderstart</b>, <b>renderend</b>, and <b>renderstep</b>
  under Screamernet.
</font>
</pre>
    </td>
  </tr>
</table>

<br><br><br><br>

<hr>
<A NAME="LSIDE">

<table border="1"
       cellpadding="3"
       cellspacing="0"
       bordercolor="#000000"
       bordercolorlight="#000000"
       width="600"
       bordercolordark="#FFFFFF">
  <tr>
    <td bgcolor="#c0c0c0">
<center><font size="+3" color="#000000">&nbsp;LSIDE Editor v1.3 Release Notes&nbsp;</font></center>
    </td>
  </tr>
</table>

<br><br>

<table border="1"
       cellpadding="3"
       cellspacing="0"
       bordercolor="#000000"
       bordercolorlight="#000000"
       width="600"
       bordercolordark="#FFFFFF">
  <tr>
    <td bgcolor="#c0c0c0">
      <table border="0"
             cellpadding="3"
             cellspacing="0"
             bordercolor="#000000"
             bordercolorlight="#000000"
             width="600"
             bordercolordark="#FFFFFF">
        <tr>
          <td width=75 bgcolor="#c0c0c0" align=left>
          </td>
          <td width=75 bgcolor="#c0c0c0" align=center>
<font size="+2" color="#000000">&nbsp;New Features&nbsp;</font>
          </td>
          <td width=75 bgcolor="#c0c0c0" align=right>
            <A HREF="#TOP">(top)</A>
          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>

<table border="2"
       cellpadding="0"
       cellspacing="0"
       bordercolor="#000000"
       bordercolorlight="#000000"
       width="600"
       bordercolordark="#FFFFFF">
  <tr>
    <td width=50>
    </td>
<!--    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF"> -->
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                        
  The LightWave LCore subsystem (which houses, among other things, LScript) has a new
  interface mechanism that allows LScript to be embedded within applications that link
  to it (currently, only internal LightWave applications can take advantage of this).

  The LSIDE Editor is the first client to use the new <b>Embedded LScript</b> mechanism of
  LCore.  A new option under the "Tools" menu called "Macro..." provides an interface
  to the management system of the Editor macros.  Selecting this menu entry opens
  a window that can be used to manage Editor macros.  Macro files have the file
  extension "els".

  A third pop-up menu has been added to the Editor's on the top-right side of the 
  interface.  It contains currently loaded macros, and is used for execution.

  The Editor supports two kinds of macros, run-once or key-based.  Run-once macros are much
  like Generic scripts in LightWave.  They execute once when invoked, and complete their
  processing when they exit.  Key-based macros (hereafter referred to as "filter" macros)
  are similar to other LightWave scripts, such as Master or Motion, in that they sit idle
  in the background when activated until either called upon to process a keystroke, or
  explicitly deactivated.

  Because the Editor's macro system is hosted by LScript, all non-LightWave-specific
  functionality offered by LScript is also available to any application using Embedded
  LScript.  This extends not only to language features, but also to certain generic built-
  in functions.

  However, an application employing Embedded LScript can define its own set of context-
  specific functions for use in its scripts.  Below is a complete list of the context
  functions defined by the LSIDE Editor.

        &lt;<font color="#0000A0">doc</font>&gt; newDoc([&lt;<font color="#0000A0">filename</font>&gt;])
<font color="#003000">
            This function creates a new document in the editor.  If a valid
            filename is provided, then that file will be loaded into the new
            document.  Otherwise, and empty document is generated.
</font>
        &lt;<font color="#0000A0">doc</font>&gt; currentDoc([&lt;<font color="#0000A0">doc</font>&gt;])
<font color="#003000">
            A handle to the current document is returned by this function.
            If a handle is provided as an argument, then that document will
            become the focus in the editor.
</font>
        &lt;<font color="#0000A0">doc</font>&gt; nextDoc(&lt;<font color="#0000A0">doc</font>&gt;)
<font color="#003000">
            This function will return a handle to the document in the system
            that follows the provided document handle (based on load order).
</font>
        saveDoc(&lt;<font color="#0000A0">doc</font>&gt;[,&lt;<font color="#0000A0">filename</font>&gt;])
<font color="#003000">
            This function will return a handle to the document in the system
            that follows the provided document handle (based on load order).
</font>
        &lt;<font color="#0000A0">integer</font>&gt; lineCount(&lt;<font color="#0000A0">doc</font>&gt;)
<font color="#003000">
            Returns the number of the lines in the provided document handle.
</font>
        &lt;<font color="#0000A0">string</font>&gt; getLine(&lt;<font color="#0000A0">doc</font>&gt;,&lt;<font color="#0000A0">line</font>&gt;)
<font color="#003000">
            Returns the content of the indicated line number in the specified
            document handle.
</font>
        &lt;<font color="#0000A0">color[]</font>&gt; getColor(&lt;<font color="#0000A0">doc</font>&gt;,&lt;<font color="#0000A0">line</font>&gt;)
<font color="#003000">
            Returns the color representation of indicated line number in the
            specified document handle.  The returned value is an array of RGB
            color values in vector form.
</font>
        addLine(&lt;<font color="#0000A0">doc</font>&gt;,&lt;<font color="#0000A0">string</font>&gt;[,&lt;<font color="#0000A0">after</font>&gt;])
<font color="#003000">
            Adds the provided string text to the indicated document handle.
            If the optional line number is included, then the line will be
            added after that line in the document.  Otherwise, the line will
            be appended to the end of the document.
</font>
        deleteLine(&lt;<font color="#0000A0">doc</font>&gt;,&lt;<font color="#0000A0">line</font>&gt;)
<font color="#003000">
            Removes the indicated line number from the specified document
            handle.
</font>
        deleteSelection(&lt;<font color="#0000A0">doc</font>&gt;)
<font color="#003000">
            Removes any currently selected text in the specified document
            handle.
</font>
        replaceLine(&lt;<font color="#0000A0">doc</font>&gt;,&lt;<font color="#0000A0">line</font>&gt;,&lt;<font color="#0000A0">string</font>&gt;)
<font color="#003000">
            Replaces the contents of the indicated line number with the
            provided text.
</font>
        replaceColor(&lt;<font color="#0000A0">doc</font>&gt;,&lt;<font color="#0000A0">line</font>&gt;,&lt;<font color="#0000A0">color[]</font>&gt;)
<font color="#003000">
            Replaces the color contents of the indicated line number with
            the provided array of color vectors.
</font>
        markLine(&lt;<font color="#0000A0">doc</font>&gt;,&lt;<font color="#0000A0">line</font>&gt;)
<font color="#003000">
            Alters the representation of the document in the editor to
            place marker to the left of the indicated line number.  This
            is identical in effect to the "Mark All Matches" setting of
            the Search dialog.
</font>
        &lt;<font color="#0000A0">Boolean</font>&gt; isDirty(&lt;<font color="#0000A0">doc</font>&gt;)
<font color="#003000">
            Allows the script to check the indicated document handle to
            see if it has been modified (i.e., is in need of saving).
</font>
        &lt;<font color="#0000A0">type</font>&gt; docType(&lt;<font color="#0000A0">doc</font>&gt;[,&lt;<font color="#0000A0">type</font>&gt;])
<font color="#003000">
            Returns the type of the document handle.  It will be one of
            <b>DOC_SCRIPT</b>, <b>DOC_CSOURCE</b>, <b>DOC_CHEADER</b>, or <b>DOC_OTHER</b>.
            Additionally, you can provide a type designation to alter the
            type of the document.  (Type designation is largely important
            for syntax hightlighting.)
</font>
        &lt;<font color="#0000A0">string</font>&gt; docName(&lt;<font color="#0000A0">doc</font>&gt;[,&lt;<font color="#0000A0">fullpath</font>&gt;])
<font color="#003000">
            Returns the name of the indicated document.  If the document
            has no name (i.e, it has not yet been saved to disc), 'nil'
            will be returned.  You can also retrieve the full path name
            of the document if you provide a Boolean <b>true</b> as the second
            argument.
</font>
        highlightSyntax(&lt;<font color="#0000A0">doc</font>&gt;)
<font color="#003000">
            Activates syntax highlighting for the specified document.
</font>
        (&lt;<font color="#0000A0">row</font>&gt;,&lt;<font color="#0000A0">col</font>&gt;) getCursor(&lt;<font color="#0000A0">doc</font>&gt;)
<font color="#003000">
            Returns the cursor's current row and column position in the
            specified document.
</font>
        setCursor(&lt;<font color="#0000A0">doc</font>&gt;,&lt;<font color="#0000A0">row</font>&gt;,&lt;<font color="#0000A0">col</font>&gt;)
<font color="#003000">
            Positions the cursor at the specified row and column in the
            specified document.
</font>
        &lt;<font color="#0000A0">Boolean</font>&gt; selection(&lt;<font color="#0000A0">doc</font>&gt;)
<font color="#003000">
            Queries the specified document to see if it has an active text
            selection.
</font>
        (&lt;<font color="#0000A0">row</font>&gt;,&lt;<font color="#0000A0">col</font>&gt;) getSelect(&lt;<font color="#0000A0">doc</font>&gt;)
<font color="#003000">
            Returns the selection's current row and column position.  When
            a selection is active, its range is increased or decreased by
            movement of the cursor.  Thus, the values returned by this
            function are the "anchor point" of the selection.
</font>
        (&lt;<font color="#0000A0">start</font>&gt;,&lt;<font color="#0000A0">end</font>&gt;) getLineSelect(&lt;<font color="#0000A0">doc</font>&gt;,&lt;<font color="#0000A0">line</font>&gt;)
<font color="#003000">
            Returns the starting and ending column of the portion of the
            indicated line that is included in the document's current
            selection.  This range can encompass the entire line, or just
            a portion depending upon the position of the cursor and
            selection anchor.
</font>
        setSelect(&lt;<font color="#0000A0">doc</font>&gt;,&lt;<font color="#0000A0">row</font>&gt;,&lt;<font color="#0000A0">col</font>&gt;)
<font color="#003000">
            Establishes the row/column position of the selection anchor
            point in the indicated document.
</font>
        &lt;<font color="#0000A0">Boolean</font>&gt; selected(&lt;<font color="#0000A0">doc</font>&gt;,&lt;<font color="#0000A0">line</font>&gt;)
<font color="#003000">
            Queries indicated line in the specified document to see if it
            is included (whether wholly or in part) in the document's current
            selection.
</font>
        &lt;<font color="#0000A0">integer</font>&gt; countChar(&lt;<font color="#0000A0">doc</font>&gt;,&lt;<font color="#0000A0">char</font>&gt;[,&lt;<font color="#0000A0">include</font>&gt;])
<font color="#003000">
            Scans the indicated document, counting the occurances of the
            provided character.  If the optional <font color="#0000A0">include</font> argument is a
            Boolean <b>true</b>, then character strings (i.e., sequences of
            characters enclosed in quotation marks) are also scanned and
            counted.
</font>
        message(&lt;<font color="#0000A0">string</font>&gt;)
<font color="#003000">
            Allows the script to display a text message in the message area
            of the editor's interface.
</font>
        &lt;<font color="#0000A0">Boolean</font>&gt; inString(&lt;<font color="#0000A0">doc</font>&gt;,&lt;<font color="#0000A0">row</font>&gt;,&lt;<font color="#0000A0">col</font>&gt;)
<font color="#003000">
            Indicates whether or not the specified row and column position in
            the document falls within a character string (i.e., a sequence of
            characters enclosed in quotation marks).
</font>
        &lt;<font color="#0000A0">Boolean</font>&gt; overwrite(&lt;<font color="#0000A0">doc</font>&gt;[,&lt;<font color="#0000A0">overwrite</font>&gt;])
<font color="#003000">
            Returns the read-only status of the indicated document, where a
            Boolean <b>true</b> indicated read-write.  The read-only status of the
            document can be set if you provide a Boolean <b>false</b> as an optional
            argument.
</font>
        &lt;<font color="#0000A0">string[]</font>&gt; funcNames(&lt;<font color="#0000A0">doc</font>&gt;)
<font color="#003000">
            Returns the names of the functions that currently exist in the
            specified document.  The document must be of type <b>DOC_SCRIPT</b> and
            functions must have been defined, or 'nil' is returned.
</font>
        &lt;<font color="#0000A0">Boolean</font>&gt; funcIsCollapsed(&lt;<font color="#0000A0">doc</font>&gt;,&lt;<font color="#0000A0">name</font>&gt;)
<font color="#003000">
            Returns the collapse status of the named function in the specified
            document.  A Boolean <b>true</b> indicates a collapsed state.
</font>
        toggleCollapse(&lt;<font color="#0000A0">doc</font>&gt;,&lt;<font color="#0000A0">name</font>&gt;)
<font color="#003000">
            Expands or collapses the function body identified by the named
            function in the specified document.  Use <b>funcIsCollapsed()</b> to check
            the function state before calling this funciton.
</font>
        &lt;<font color="#0000A0">integer</font>&gt; funcLine(&lt;<font color="#0000A0">doc</font>&gt;,&lt;<font color="#0000A0">name</font>&gt;)
<font color="#003000">
            Returns the line number of the named function in the specified
            document.  If the named function does not exist, then 'nil' is
            returned.
</font>
  The following functions are available only to filter macros:

        replaceKey(&lt;<font color="#0000A0">key</font>&gt;)
<font color="#003000">
            Substitutes the provided key value for the one currently being
            processed.  All subsequent key filters will receive this
            replacement key value when they are invoked instead of the
            original.  This new key will also be the value passed on to
            the editor, if indicated.
</font>
<!--        &lt;<font color="#0000A0">keys[]</font>&gt; modifiers() -->
  All macro types have a central point of entry called "macro".  This is where execution of
  the Editor macro begins, and, in the case of run-once macros, terminates when the macro()
  function completes.

<font color="#0000A0">        macro
        {
            ...
        }</font>

  Filter macros provide an additional user-defined function, called <b>filter()</b>, that serves
  two purposes.  First, its presence identifies the macro as a key-based filter.  Second,
  it acts like a LightWave LScript <b>flags()</b> function and returns one or more characters
  for which it should be activated.  For this latter functionality, the <b>filter()</b> function
  can return a combination of character strings and integer values that will map to
  the required key values:

<font color="#0000A0">        filter
        {
            return("\ta",13);    // trap tabs, lower-case 'a', and the Return key
        }</font>

  The <b>filter()</b> function will be invoked by the Editor's macro system each time the
  macro is activated.  This can occur when the macro is first loaded at startup (if
  it was active during your last session), or when you explicitly activate the macro
  from the interface.  For this reason, it serves as a good location to initialize
  the state of the macro, if needed.

<font color="#0000A0">        filter
        {
            pastPartials = nil;  // reset for a new run...
            return("\ta",13);    // trap tabs, lower-case 'a', and the Return key
        }</font>

  The macro() function of a filter macro can also accept one or two optional arguments which
  represent the active document and the key to be processed.  In filter macros where only a
  single key is being trapped, this second argument is unnecessary.  And, because the currentDoc()
  function will return a handle to the active document, getting it in the argument list is
  also redundant.  However, in cases where more than one key is being intercepted, or in the
  case where a filter macro is trapping all printable characters, these arguments can be useful
  (for determining the key that caused the event in the former case, and for execution speed
  in the latter).  The key argument provided is the integer value of the event key.

<font color="#0000A0">        filter
        {
            pastPartials = nil;  // reset for a new run...
            return("\ta",13);    // trap tabs, lower-case 'a', and the Return key
        }

        macro: doc, key
        {
            switch(key)
            {
                case '\t':      // tab
                    ...
                    break;

                case 'a':
                    ...
                    break;

                case 13:        // Return
                    ...
                    break;
            }
        }</font>

  Several LScript pragmas can be used by scripts excuted by Embedded LScript.  For instance,
  the @name pragma can (and <i><b>must</b></i>) be present in an Editor macro, and is used to set the name
  of the macro in the list on the user interface.

<font color="#0000A0">        @name Sort Ascending

        macro
        {
            ...
        }</font>

  Any other LScript pragma not having to do directly with LightWave (@fpdepth, @define,
  @strict, etc.) can also be present in an Editor (Embedded LScript) macro.

  Here are some example macros that were created during the development of the Editor's
  macro sytem.  Some are practical, and some are useful only as examples of how to use
  some of the provided context functions:

        Name                Type            Description
        ------------------  --------------  --------------------------------------------
        <a href="javascript:openWindow('LSIDE/autosave.els');">autosave.els</a>        filter          saves the current document after a specified
                                            number of keystrokes
        <a href="javascript:openWindow('LSIDE/a_to_A.els');">a_to_A.els</a>          filter          uses the replaceKey() function to capatilize
                                            all typed lower-case 'a' characters
        <a href="javascript:openWindow('LSIDE/cf_template.els');">cf_template.els</a>     run-once        simple script that creates a new document and
                                            places a Channel Filter template into it
        <a href="javascript:openWindow('LSIDE/changecase.els');">changecase.els</a>      run-once        alters the case of the characters in the document.
                                            adheres to any current selection.  employs the
                                            LScript requester mechanism.
        <a href="javascript:openWindow('LSIDE/color_e.els');">color_e.els</a>         run-once        changes the color of all the 'e' or 'E' characters
                                            on the current line
        <a href="javascript:openWindow('LSIDE/disablecode.els');">disablecode.els</a>     run-once        places a single-line comment operator (//) at
                                            the start of every line in the current selection
        <a href="javascript:openWindow('LSIDE/enablecode.els');">enablecode.els</a>      run-once        removes any single-line comment operators from
                                            the start of every line in the selection
        <a href="javascript:openWindow('LSIDE/keycomplete.els');">keycomplete.els</a>     filter          completes the keyword from a partial entry when
                                            the tab key is pressed
        <a href="javascript:openWindow('LSIDE/reformat.els');">reformat.els</a>        run-once        re-formats a script to make it more readable
        <a href="javascript:openWindow('LSIDE/smartindent.els');">smartindent.els</a>     filter          automates code-based indentation in a smart
                                            fashion
        <a href="javascript:openWindow('LSIDE/sort.els');">sort.els</a>            run-once        sorts selected document lines in ascending order

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  Document text can now be scrolled using the mouse wheel on mice that provide them.  In
  addition, the wheel provides acceleration scrolling.  Shorter times between individual
  wheel clicks will scroll more lines.

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  File-open dialogs in the Editor are now multiple-select.
</font>
</pre>
    </td>
  </tr>
</table>

<br><br><br>

<table border="1"
       cellpadding="3"
       cellspacing="0"
       bordercolor="#000000"
       bordercolorlight="#000000"
       width="600"
       bordercolordark="#FFFFFF">
  <tr>
    <td bgcolor="#c0c0c0">
      <table border="0"
             cellpadding="3"
             cellspacing="0"
             bordercolor="#000000"
             bordercolorlight="#000000"
             width="600"
             bordercolordark="#FFFFFF">
        <tr>
          <td width=75 bgcolor="#c0c0c0" align=left>
            <A HREF="#LSIDE">(LSIDE)</A>
          </td>
          <td width=75 bgcolor="#c0c0c0" align=center>
<font size="+2" color="#000000">&nbsp;Behavioral Changes&nbsp;</font>
          </td>
          <td width=75 bgcolor="#c0c0c0" align=right>
            <A HREF="#TOP">(top)</A>
          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>

<table border="2"
       cellpadding="0"
       cellspacing="0"
       bordercolor="#000000"
       bordercolorlight="#000000"
       width="600"
       bordercolordark="#FFFFFF">
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0"><pre>
<font color="#000000">
                                                                                                    
  The Editor's undo system has been redesigned.  The redesign not only makes the undo
  mechanism function correctly, the addition of on-the-fly compression code now also
  allows for undo operations to be more numerous per document while consuming the same
  amount of memory.

  Instead of being limited to a specific number of events, the undo system now limits
  undo events to a cumulative memory size (500K per document in this release).  When this
  limit is exceeded by a change in the document, the oldest undo events are discarded
  until the cumulative memory consumption of undo events falls again below the specified
  maximum.  The actual number of events discarded will depend upon their particular
  memory footprint in this undo pool.
</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  The replace mechanism now functions strictly within a selection range if one has
  been applied to the document.
</font>
</pre>
    </td>
  </tr>
</table>

<br><br><br>

<A NAME="EXPRESS">

<table border="1"
       cellpadding="3"
       cellspacing="0"
       bordercolor="#000000"
       bordercolorlight="#000000"
       width="600"
       bordercolordark="#FFFFFF">
  <tr>
    <td bgcolor="#c0c0c0">
<center><font size="+3" color="#000000">&nbsp;Expressions&nbsp;</font></center>
    </td>
  </tr>
</table>

<br><br>

<table border="1"
       cellpadding="3"
       cellspacing="0"
       bordercolor="#000000"
       bordercolorlight="#000000"
       width="600"
       bordercolordark="#FFFFFF">
  <tr>
    <td bgcolor="#c0c0c0">
      <table border="0"
             cellpadding="3"
             cellspacing="0"
             bordercolor="#000000"
             bordercolorlight="#000000"
             width="600"
             bordercolordark="#FFFFFF">
        <tr>
          <td width=75 bgcolor="#c0c0c0" align=left>
          </td>
          <td width=75 bgcolor="#c0c0c0" align=center>
<font size="+2" color="#000000">&nbsp;New Features&nbsp;</font>
          </td>
          <td width=75 bgcolor="#c0c0c0" align=right>
            <A HREF="#TOP">(top)</A>
          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>

<table border="2"
       cellpadding="0"
       cellspacing="0"
       bordercolor="#000000"
       bordercolorlight="#000000"
       width="600"
       bordercolordark="#FFFFFF">
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#c0c0c0">
<pre>
<font color="#000000">
                                                                                                    
  Employing Embedded LScript, users can now write their own functions for use with LightWave
  Expressions.

  Expressions UDFs are used just like any built-in Expressions function.  Parameter passing
  is limited to simple data types--strings, numbers and vectors.  As long as an expression
  evaluates to one of these data types, it can be used as an argument.

  Expressions UDFs are stored in the \NewTek\LScripts directory within their own directory
  called "expressions".  A default library of functions can be maintained within this
  directory called "library.ls".  This library of functions is automatically loaded into the
  Expressions engine when LightWave is initialized, and its defined functions are consequently
  available to any LightWave expression or Expressions UDFs that references them.

  Additionally, individual Expressions UDFs can be stored in their own files in this same
  directory.  The name of the file containing the UDF must exactly match that of the function
  name being referenced.  The file may contain any number of other UDFs to support the main
  function, but must contain at least a UDF whose name and argument count matches that being
  referenced in the expression.

  Data exchange between UDFs is not limited in their types.  UDF-to-UDF calling is exactly
  the same as it is in LScript.

  By way of example, assume the following files exist in the required directory:

        \NewTek\LScripts\expressions\library.ls
        \NewTek\LScripts\expressions\channelValue.ls

  The "library.ls" file contains the following content:

<font color="#0000A0">        locate_channel: fullchannel
        {
            parts = parse(".",fullchannel);

            group = ChannelGroup(parts[1]);  // start with root channel group
            lastgroup = group;
            subgroup = nil;
            x = 2;

            while(group)
            {
                // scan sub-groups to match parts[x]
                // if a match can't be found, then it
                // is probably the start of the channel
                // name

                subgroup = ChannelGroup(group,subgroup);
                last if !subgroup;

                if(subgroup.name == parts[x])
                {
                    group = subgroup;
                    lastgroup = group;
                    subgroup = nil;
                    ++x;
                }
            }

            if(!lastgroup) return(nil);

            // anything left in the parts[] array are the components
            // of the channel name itself.  put them together for
            // channel searching

            channelname = "";   // avoid creating an array
            psize = parts.size();

            while(x <= psize)
            {
                channelname += parts[x];
                if(x < psize) channelname += ".";
                ++x;
            }

            // scan the defined channels in the final group to see
            // if we can match the channel name

            chchannel = lastgroup.firstChannel();
            while(chchannel)
            {
                last if chchannel.name == channelname;
                chchannel = lastgroup.nextChannel();
            }

            return(chchannel);
        }

        // replace the built-in clamp() function

        clamp: val, lower, upper
        {
                                 result = val;
            if(val < lower)      result = lower;
            else if(val > upper) result = upper;

            return(result);
        }</font>


  While the "channelValue.ls" file contains the following content:

<font color="#0000A0">        chan;
        chanName;

        channelValue: channel, time
        {
            if(chanName != channel) chan = nil;

            if(!chan)
            {
                // cache the channel for speed
                chan = locate_channel(channel);
                if(!chan) return(0);
                chanName = channel;
            }

            return(chan.value(time));
        }</font>

  In Layout, you might then enter an expression like:

<font color="#0000A0">        clamp(channelValue("WashLight.Intensity",Time),0.0,1.0)</font>

  This will invoke the channelValue() UDF, which then invokes the locate_channel() UDF
  (defined in the default library file "library.ls") to resolve a string channel reference to
  an actual LScript Channel Object Agent.  The channelValue() UDF returns the value of the
  specified Light Object's intensity value at the current time.  This value is then passed to
  the (script) clamp() UDF (also defined in "library.ls") to keep it in a specified range.

  Alternately, you could use the Graph Editor's direct channel reference syntax with the
  UDF call:

<font color="#0000A0">        clamp([WashLight.Intensity,Time],0.0,1.0)</font>

  UDF references that have been loaded into the Expressions engine are automatically updated
  the next time they are evaluated when their respective files have been modified.  For instance,
  if you have expressions referencing channelValue(), altering the last line of the function to
  read:

<font color="#0000A0">            return(chan.value(time) + 1.0);</font>

  will instantly return new values the next time the expression is evaluated (e.g., on the
  next frame).

</font>
</pre>
    </td>
  </tr>
  <tr>
    <td width=50>
    </td>
    <td bgcolor="#505050">
<pre>
<font color="#FFFFFF">
                                                                                                    
  The existing Expressions <b>log()</b> function calculates the natural logarithm (base-<i>e</i>) of the provided
  value.  This can be a bit misleading for those seeking base-10 functionality, so a new function
  has been added, <b>log10()</b>, to address this.

</font>
</pre>
    </td>
  </tr>
</table>

<br><br><br><br>

</CENTER>

</BODY>
