<html>

<head>
<title>Classes: MeshDataEdit</title>
<style type="text/css"><!--tt { font-size: 10pt } pre { font-size: 10pt }--></style>
</head>

<body bgcolor="#ffffff" text="#000000" link="#000080" vlink="#800000" alink="#0000ff">

<table border="0" cellpadding="0" cellspacing="0" bgcolor="#d0d0d0">
  <tr>
    <td width="120" align="left"><a href="master.html"><img width="96" height="20" border="0"
    src="../images/navlt.gif" alt="MasterHandler"></a></td>
    <td width="96" align="left"><a href="metool.html"><img width="64" height="20" border="0"
    src="../images/navrt.gif" alt="MeshEditTool"></a></td>
    <td width="96" align="left"><a href="../classes.html"><img width="56" height="20"
    border="0" src="../images/navup.gif" alt="Classes"></a></td>
    <td width="288" align="right"><a href="../index.html"><img width="230" height="20"
    border="0" src="../images/proglw.gif" alt="Table of Contents"></a></td>
  </tr>
</table>

<table border="0" cellpadding="0" cellspacing="0">
  <tr>
    <td width="600"><br>
<h3>MeshDataEdit</h3>

<p style="font-size: smaller">
    <b>Availability</b>&nbsp; LightWave&reg; 6.0<br>
    <b>Component</b>&nbsp; Modeler<br>
    <b>Header</b>&nbsp; <a href="../../include/lwmeshedt.h">lwmeshedt.h</a>
</p>

<p>
    Mesh edit plug-ins create and modify geometry at the point and polygon level. This
    class is a subset of the <a href="cs.html">CommandSequence</a> class, which provides
    access to both mesh editing and <a href="../commands.html">commands</a>, and of the <a
    href="metool.html">MeshEditTool</a> class, an interactive version of MeshDataEdit.
</p>

<!-- ------------------------------------------------------------------------------- -->
<p><b>Activation Function</b></p>

<pre>   XCALL_( int ) MyMeshEdit( int version, GlobalFunc *global,
        MeshEditBegin *local, void *serverData );
</pre>
  
<p>
    The <tt>local</tt> argument to a mesh edit plug-in's activation function is a
    MeshEditBegin.
</p>
<pre>   typedef MeshEditOp *
        MeshEditBegin (int pntBuf, int polBuf, EltOpSelect);
</pre>

<p>
    This function returns a MeshEditOp structure containing the mesh editing functions. It
    can be called only once for each activation.
</p>

<p>
    The MeshEditBegin function can allocate a user data buffer for each point and polygon.
    This is memory you can use to store per-point and per-polygon information during the edit.
    Modeler automatically frees these buffers when the edit is completed. The <tt>pntBuf</tt>
    and <tt>polBuf</tt> arguments set the sizes of the buffers.
</p>

<!-- ------------------------------------------------------------------------------- -->
<p><a name="eltopselect"><b>EltOpSelect</b></a></p>
<p>
    When the edit begins, Modeler sets a selection flag for each point and polygon. The
    EltOpSelect code determines which geometry is flagged as selected, and it can be one of
    the following.
    
    <dl>
        <dt>OPSEL_GLOBAL</dt>
        <dd>All elements, whether or not they're selected by the user.</dd>
        
        <dt>OPSEL_USER</dt>
        <dd>
            Only those elements selected by the user. This includes the implicit selection of all
            elements when nothing is explicitly selected, and selections by volume.
        </dd>
        
        <dt>OPSEL_DIRECT</dt>
        <dd>
            Elements selected directly with the point or polygon selection tools. This applies to
            both points and polygons regardless of which is currently active in the interface.
        </dd>
        
        <dt>OPSEL_MODIFY</dt>
        <dd>
            This activates a special mesh edit mode that can change the selection state of specific
            points and polygons. The mesh editing functions for adding and changing geometry aren't
            available in this mode, but the query functions can be used. The selection state of a
            point or polygon is modified by calling the MeshEditOp <tt>pntSelect</tt> or <tt>polSelect</tt>
            functions, typically within a <tt>pointScan</tt> or <tt>polyScan</tt> callback. <tt>OPSEL_MODIFY</tt>
            must be combined with one of the other selection modes in the MeshEditBegin call.
        </dd>
    </dl>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p><b><a name="eltoplayer">EltOpLayer</a></b></p>
<p>Many of the MeshEditOp functions operate on a specific set of layers, and these are
identified by an EltOpLayer code.
<dl>
    <dt>OPLYR_PRIMARY</dt>
    <dd>
        The primary layer. This is the single active layer affected by mesh edits, normally the
        lowest numbered foreground layer.
    </dd>
    
    <dt>OPLYR_FG</dt>
    <dd>Foreground layers, which are active and displayed.</dd>
    
    <dt>OPLYR_BG</dt>
    <dd>Background layers, which are inactive but still displayed.</dd>
    
    <dt>OPLYR_SELECT</dt>
    <dd>Both foreground and background layers.</dd>
    
    <dt>OPLYR_ALL</dt>
    <dd>All layers in the Modeler system whether they contain data or not.</dd>
    
    <dt>OPLYR_EMPTY</dt>
    <dd>Empty layers are those that contain no geometry.</dd>

    <dt>OPLYR_NONEMPTY</dt>
    <dd>Non-empty layers are any layers which contain some data (the complement of <tt>OPLYR_EMPTY</tt>).</dd>

    <dt>Individual Layers</dt>
    <dd>
        In addition to the defined values, codes starting at 101 (for layer 1) can be used to
        select the individual layers by number.
    </dd>
</dl>

<!-- ------------------------------------------------------------------------------- -->
<p style="font: bold">Error Codes</p>
<p>
    Most of the mesh edit functions return an error state defined by one of the following
    codes. One of these is also passed to the MeshEditOp <tt>done</tt> function.
    <dl>
        <dt>EDERR_NONE</dt>
        <dd>Success.</dd>
        
        <dt>EDERR_NOMEMORY</dt>
        <dd>A memory allocation failed.</dd>
        
        <dt>EDERR_BADLAYER</dt>
        <dd>An operation was attempted in an invalid layer.</dd>
        
        <dt>EDERR_BADSURF</dt>
        <dd>The edit created an invalid surface name.</dd>

        <dt>EDERR_USERABORT</dt>
        <dd>The user (or the plug-in) ended the edit before it was completed.</dd>

        <dt>EDERR_BADVMAP</dt>
        <dd>The operation involved an invalid vertex map.</dd>

        <dt>EDERR_BADARGS</dt>
        <dd>The function failed for a reason not covered by the other error codes.</dd>
    </dl>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p style="font: bold">MeshEditOp</p>
<p>
    The MeshEditBegin function returns a MeshEditOp containing data and functions for
    performing mesh edits.
</p>

<pre>typedef struct st_MeshEditOp
{
    EDStateRef        <b>state</b>;
    int               <b>layerNum</b>;
    
    void            (*<b>done</b>)             (EDStateRef, EDError, int selm);
    
    int             (*<b>pointCount</b>)       (EDStateRef, EltOpLayer, int mode);
    EDError         (*<b>edgeCount</b>)        (EDStateRef, EltOpLayer, int mode);
    int             (*<b>polyCount</b>)        (EDStateRef, EltOpLayer, int mode);
    
    EDError         (*<b>pointScan</b>)        (EDStateRef, EDPointScanFunc *, void *, EltOpLayer);
    EDError         (*<b>edgeScan</b>)         (EDStateRef, EDEdgeScanFunc*, void*, EltOpLayer);
    EDError         (*<b>polyScan</b>)         (EDStateRef, EDPolyScanFunc *, void *, EltOpLayer);
    
    EDError         (*<b>fastPointScan</b>)    (EDStateRef, EDFastPointScanFunc*, void*, EltOpLayer, int);
    EDError         (*<b>fastEdgeScan</b>)     (EDStateRef, EDFastEdgeScanFunc*, void*, EltOpLayer, int);
    EDError         (*<b>fastPolyScan</b>)     (EDStateRef, EDFastPolyScanFunc*, void*, EltOpLayer, int);
    
    EDPointInfo *   (*<b>pointInfo</b>)        (EDStateRef, LWPntID);
    EDEdgeInfo *    (*<b>edgeInfo</b>)         (EDStateRef, LWEdgeID);
    EDPolygonInfo * (*<b>polyInfo</b>)         (EDStateRef, LWPolID);
    
    int             (*<b>polyNormal</b>)       (EDStateRef, LWPolID, double[3]);
    unsigned int    (*<b>polyType</b>)         (EDStateRef, LWPolID);
    int             (*<b>polyPoints</b>)       (EDStateRef, LWPolID, const LWPntID**);
    
    LWPntID         (*<b>addPoint</b>)         (EDStateRef, double *xyz);
    LWPolID         (*<b>addFace</b>)          (EDStateRef, const char *surf, int numPnt, const LWPntID *);
    LWPolID         (*<b>addCurve</b>)         (EDStateRef, const char *surf, int numPnt, const LWPntID *, int flags);
    EDError         (*<b>addQuad</b>)          (EDStateRef, LWPntID, LWPntID, LWPntID, LWPntID);
    EDError         (*<b>addTri</b>)           (EDStateRef, LWPntID, LWPntID, LWPntID);
    EDError         (*<b>addPatch</b>)         (EDStateRef, int nr, int nc, int lr, int lc,
                                                     EDBoundCv *r0, EDBoundCv *r1, EDBoundCv *c0, EDBoundCv *c1);
    
    EDError         (*<b>remPoint</b>)         (EDStateRef, LWPntID);
    EDError         (*<b>remPoly</b>)          (EDStateRef, LWPolID);
    
    EDError         (*<b>pntMove</b>)          (EDStateRef, LWPntID, const double *);
    EDError         (*<b>polSurf</b>)          (EDStateRef, LWPolID, const char *);
    EDError         (*<b>polPnts</b>)          (EDStateRef, LWPolID, int, const LWPntID *);
    EDError         (*<b>polFlag</b>)          (EDStateRef, LWPolID, int mask, int value);
    
    EDError         (*<b>polTag</b>)           (EDStateRef, LWPolID, LWID, const char *);
    EDError         (*<b>pntVMap</b>)          (EDStateRef, LWPntID, LWID, const char *, int, float *);
    
    LWPolID         (*<b>addPoly</b>)          (EDStateRef, LWID type, LWPolID, const char *surf, int numPnt, const LWPntID *);
    LWPntID         (*<b>addIPnt</b>)          (EDStateRef, double *xyz, int numPnt, const LWPntID *, const double *wt);
    EDError         (*<b>initUV</b>)           (EDStateRef, float *uv);
    
    void *          (*<b>pointVSet</b>)        (EDStateRef, void *, LWID, const char *);
    int             (*<b>pointVGet</b>)        (EDStateRef, LWPntID, float *);
    const char *    (*<b>polyTag</b>)          (EDStateRef, LWPolID, LWID);
    
    EDError         (*<b>pntSelect</b>)        (EDStateRef, LWPntID, int);
    EDError         (*<b>edgeSelect</b>)       (EDStateRef, LWEdgeID, int);
    EDError         (*<b>polSelect</b>)        (EDStateRef, LWPolID, int);
    
    int             (*<b>pointVPGet</b>)       (EDStateRef, LWPntID, LWPolID, float *);
    int             (*<b>pointVEval</b>)       (EDStateRef, LWPntID, LWPolID, float *);
    EDError         (*<b>pntVPMap</b>)         (EDStateRef, LWPntID, LWPolID, LWID, const char *, int, float *);
    
    int             (*<b>edgePolys</b>)        (EDStateRef, LWEdgeID, const LWPolID**);
    LWPntID         (*<b>edgePoint1</b>)       (EDStateRef, LWEdgeID);
    LWPntID         (*<b>edgePoint2</b>)       (EDStateRef, LWEdgeID);
    LWEdgeID        (*<b>edgeFromPoints</b>)   (EDStateRef, LWPntID, LWPntID);
    
    void            (*<b>pointPos</b>)         (EDStateRef, LWPntID, double[3]);
    int             (*<b>pointEdges</b>)       (EDStateRef, LWPntID, const LWEdgeID**);
    
    int             (*<b>pointFlags</b>)       (EDStateRef, LWPntID);
    int             (*<b>edgeFlags</b>)        (EDStateRef, LWEdgeID);
    int             (*<b>polyFlags</b>)        (EDStateRef, LWPolID);

    void *          (*<b>vMapSelect</b>)       (EDStateRef es, const char* name, LWID type, int dim);
    int             (*<b>vMapExists</b>)       (EDStateRef es, const char* name, LWID type);
    unsigned int    (*<b>vMapGetDimension</b>) (EDStateRef es);
    void            (*<b>vMapSet</b>)          (EDStateRef es, LWPntID point_id, const float *value);
    void            (*<b>vMapPSet</b>)         (EDStateRef es, LWPntID point_id, LWPolID polygon_id, const float *value);
    void            (*<b>vMapSetIdeal</b>)     (EDStateRef es, LWPntID point_id, LWPolID polygon_id, const float *value);
    void            (*<b>vMapRemove</b>)       (EDStateRef es);
    void            (*<b>vMapRename</b>)       (EDStateRef es, const char *new_name);

} MeshEditOp;
</pre>

<dl>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt><b>state</b></dt>
    <dd>
        An opaque pointer to data used internally by Modeler during the mesh edit. Pass this as
        the first argument to all of the edit functions.
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt><b>layerNum</b></dt>
    <dd>
        Points and polygons may only be created or modified in the primary active layer, which
        is given by this layer number. The primary layer is the lowest numbered foreground layer.
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt><b>done</b>( state, error, selset )</dt>
    <dd>
        Call this when the edit is complete. As changes are made during an edit, they are
        buffered through Modeler's undo mechanism, so they are not reflected in the data until
        done is called, and not at all if <tt>done</tt> sets the error argument. 
        
        <p>
            In general, if one of the edit functions returns an error, you'll pass that error to <tt>done</tt>. If
            you just want the edit to stop or be discarded, possibly because the user pressed the
            Cancel button in a progress <a href="../globals/modmon.html">monitor</a>, you'll pass <tt>EDERR_USERABORT</tt>.
            If an error occurs in your plug-in, you'll pass <tt>EDERR_NOMEMORY</tt> (for memory
            allocation errors) or <tt>EDERR_BADARGS</tt> (for everything else). And if the edit was
            successful, you'll use <tt>EDERR_NONE</tt>.
        </p>
        
        <p>
            The <tt>selset</tt> argument tells Modeler how you want the selection to appear to the
            user after the edit has been applied. It contains flags combined using bitwise-or, and can
            include the following.
    
            <dl>
                <dt><br>EDSELM_CLEARCURRENT</dt>
                <dd>Deselect elements that were selected when the edit began.</dd>
                
                <dt>EDSELM_SELECTNEW</dt>
                <dd>Select elements created by the edit.</dd>
                
                <dt>EDSELM_FORCEVRTS</dt>
                <dd>Force selection of newly created vertices.</dd>
                
                <dt>EDSELM_FORCEPOLS</dt>
                <dd>Force selection of newly created polygons.</dd>
            </dl>
        </p>
    
        <p>
            A value of 0 leaves all directly selected elements selected after the edit. The <tt>CLEARCURRENT</tt>
            and <tt>SELECTNEW</tt> flags are polite hints; they won't override selection settings made
            by the user. The force flags will always force direct selection of the points or polygons
            created by the edit.
        </p>
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>npoints = <b>pointCount</b>( state, oplayer, selmode ) <br>npolygons = <b>polyCount</b>( state, oplayer, selmode )</dt>
    <dd>
        Returns the number of points or polygons that meet the layer and selection criteria.
        The selection mode can be one of the following.
        <dl>
            <dt><br>EDCOUNT_ALL</dt>
                <dd>Both selected and unselected points or polygons.</dd>
    
            <dt>EDCOUNT_SELECT</dt>
                <dd>Only selected points or polygons.</dd>
    
            <dt>EDCOUNT_DELETE</dt>
                <dd>Only points or polygons flagged for deletion by this mesh edit.</dd>
        </dl>
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>    <br>err = <b>pointScan</b>( state, scanfunc, userdata, oplayer )
            <br>err = <b>edgeScan</b>( state, scanfunc, userdata, oplayer )
            <br>err = <b>polyScan</b>( state, scanfunc, userdata, oplayer )
    </dt>
    <dd>
        Enumerate geometry in the specified layers. For each element, Modeler
        calls the callback function you supply. The callbacks are defined this way.
    
        <p><tt>
            typedef EDError EDPointScanFunc (void *, const EDPointInfo *);<br>
            typedef EDError EDEdgeScanFunc (void *, const EDEdgeInfo *)<br>
            typedef EDError EDPolyScanFunc (void *, const EDPolygonInfo *)
        </tt></p>
    
        <p>
            The <tt>userdata</tt> pointer is passed as the first argument to your callbacks, and it
            can be whatever is useful to you. The point and polygon info structures passed as the
            second argument are described later. If your callback returns an error, the scan is
            stopped and the callback's error is returned.
        </p>
        
        <p>
            Point and polygon scans will enumerate all of the geometry in the layers you request,
            regardless of what geometry is selected, even if you begin the edit with <tt>OPSEL_USER</tt>
            or <tt>OPSEL_DIRECT</tt>. To find out whether a given element is selected (as defined by
            your choice of EltOpSelect), you need to test the EDPointInfo or EDPolygonInfo <tt>flags</tt>
            field for the <tt>EDDF_SELECT</tt> bit. Similarly, if you've deleted geometry during the
            mesh edit, it will still be enumerated, but the flags field of the info structure will
            contain <tt>EDDF_DELETE</tt>.
        </p>
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>    <br>err = <b>fastPointScan</b>( state, scanfunc, userdata, oplayer, selected_only )
            <br>err = <b>fastEdgeScan</b>( state, scanfunc, userdata, oplayer, selected_only )
            <br>err = <b>fastPolyScan</b>( state, scanfunc, userdata, oplayer, selected_only )
    </dt>
    <dd>
        These are like the above versions, but do not provide complete info structures at every iteration. 
        Instead, the callbacks are supplied element IDs from which the necessary data can be extracted.
        There is also a <tt>selected_only</tt> parameter which can be specified to true, in which case the scan function 
        is only applied for the selected elements only. This is more efficient than checking for the <tt>EDDF_SELECT</tt>
        flag at every scan iteration. 
        
        The callbacks are defined like so:
    
        <p><tt>
            typedef EDError EDPointScanFunc (void *, LWPntID);<br>
            typedef EDError EDEdgeScanFunc (void *, LWEdgeID)<br>
            typedef EDError EDPolyScanFunc (void *, LWPolID)
        </tt></p>
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>
        info = <b>pointInfo</b>( state, point )<br>
        info = <b>edgeInfo</b>( state, edge )<br>
        info = <b>polyInfo</b>( state, polygon )
    </dt>
    <dd>
        Returns information about a point, edge, or polygon. These return the same EDPointInfo,
        EDEdgeInfo, and EDPolygonInfo structures that are passed to the scan callbacks.
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>ok = <b>polyNormal</b>( state, polygon, norm )</dt>
    <dd>
        Get a polygon's normal. The normal is a unit vector perpendicular to the plane defined
        by the first, second and last vertex of the polygon. If the polygon has fewer than three
        vertices, or is somehow degenerate, <tt>norm</tt> isn't changed and the function returns
        0. Otherwise it returns 1 and <tt>norm</tt> receives the normal.
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>point = <b>addPoint</b>( state, pos )</dt>
    <dd>Create a point.</dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt><br>polygon = <b>addFace</b>( state, surfname, npoints, point_array )</dt>
    <dd>
        Create a polygon. If the surface name is NULL, the polygon will be assigned the current
        default surface. The vertices are defined by an array of point IDs listed in clockwise
        order. The polygon normal will be inferred from the first, second and last points.
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt><br>polygon = <b>addCurve</b>( state, surfname, npoints, point_array, flags )</dt>
    <dd>
        Create a curve (a polygon of type <tt>LWPOLTYPE_CURV</tt>). The <tt>EDPF_CCSTART</tt>
        and <tt>EDPF_CCEND</tt> flags specify that the first and last points in the point array
        should serve as control points and not be included in the curve itself. To create a closed
        curve, both of these flags must be set, and the first and last point must overlap.
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>
        err = <b>addQuad</b>( state, v1, v2, v3, v4 )<br>
        err = <b>addTri</b>( state, v1, v2, v3 )
    </dt>
  
    <dd>
        Create a quadrangle or a triangle with the current default surface. These two functions
        respect the user's settings for new geometry. Two collocated polygons with opposite
        normals will be created if the user has set the double-sided option, and quads will be
        split into two triangles if the user has set the triangles-only option.
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>err = <b>addPatch</b>( state, nr, nc, lr, lc, r0, r1, c0, c1 )</dt>
    <dd>
        Create a polygonal patch defined by three or four bounding curves. The first two
        arguments (after the EditStateRef) give the number of patch divisions in the R (row) and C
        (column) directions. The second two arguments are booleans; if 0, the divisions are
        equally spaced along the curve, and if 1, the spacing is determined by the positions of
        the curve knots. The last four arguments are the bounding curves, each defined by an
        EDBoundCV structure. 

<pre>typedef struct st_EDBoundCv 
{
    LWPolID curve;
    int     start, end;
} EDBoundCv;
</pre>

        <p>
            The <tt>start</tt> and <tt>end</tt> indexes are the points on the curve that should be
            used as endpoints for patching. The first and second curves define the R boundaries. The
            third and optional fourth curve define the C boundaries.
        </p>
    </dd>
</p>
  
<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>err = <b>remPoint</b>( state, point )</dt>
    <dd>
        Delete the point. Modeler will flag the point as deleted, but will actually remove it
        from the database only after <tt>done</tt> is called.
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>err = <b>remPoly</b>( state, polygon )</dt>
    <dd>Delete the polygon.</dd>
</p>
  
<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>err = <b>pntMove</b>( state, point, pos )</dt>
    <dd>Put a point in a new position.</dd>
</p>
  
<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>err = <b>polSurf</b>( state, polygon, surfname )</dt>
    <dd>Change the surface assigned to a polygon.</dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>err = <b>polPnts</b>( state, polygon, npoints, point_array )</dt>
    <dd>Replace the point list of a polygon.</dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt><br>err = <b>polFlag</b>( state, polygon, mask, value )</dt>
    <dd>
        Set polygon flags. The mask contains 1 bits for each flag you want to change, and the
        value contains the new flag settings (0 or 1 for each 1 bit in the mask). Currently, the
        flags that can be changed are the <tt>EDPF_START</tt> and <tt>EDPF_END</tt> flags for
        curves.
    </dd>
</p>
   
<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>err = <b>polTag</b>( state, polygon, tagtype, tag )</dt>
    <dd>
        Add a polygon tag to a polygon, or change an existing tag. If the tag type is <tt>LWPTAG_SURF</tt>,
        the tag is the surface name. If the tag type is <tt>LWPTAG_PART</tt>, the tag is the part
        (or group) name. For anything other than surface tags, passing a NULL <tt>tag</tt> will
        remove an existing tag of the specified type.
    </dd>
</p>
    
<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>err = <b>pntVMap</b>( state, point, type, name, nvalues, val_array )</dt>
    <dd>
        Add a vmap vector to a point. The vmap type can be one of the following, or something
        else.
        
        <p>
            <tt>LWVMAP_PICK</tt> - selection set<br>
            <tt>LWVMAP_WGHT</tt> - weight map<br>
            <tt>LWVMAP_MNVW</tt> - subpatch weight map<br>
            <tt>LWVMAP_TXUV</tt> - texture UV coordinates<br>
            <tt>LWVMAP_MORF</tt> - relative vertex displacement (morph)<br>
            <tt>LWVMAP_SPOT</tt> - absolute vertex displacement (morph)<br>
            <tt>LWVMAP_RGB</tt>, <tt>LWVMAP_RGBA</tt> - vertex color<br>
            <tt>LWVMAP_NORM</tt> - vertex normals            
        </p>

        <p>Pass a NULL <tt>val_array</tt> to <em>remove</em> a vmap vector from the point.</p>
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>polygon = <b>addPoly</b>( state, type, template, surf, npoints, point_array )</dt>
    <dd>
        Create a polygon. If a template polygon is supplied, Modeler copies the polygon tags for
        the new polygon from the template. If the surface name is NULL, the surface will be that
        of the template, or the current default surface if the template is NULL. The vertices of
        the new polygon are listed in clockwise order, and the normal will be inferred from the
        first, second and last vertex.
    </dd>
</p>
    
<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>point = <b>addIPnt</b>( state, pos, npoints, point_array, weight_array )</dt>
    <dd>
        Create an &quot;interpolated&quot; point. The new point's vmap values are calculated as
        a weighted average of the vmaps of the points in the points array. If <tt>pos</tt> is
        NULL, the position is also computed as a weighted average. If the weight array is NULL,
        the averaging over the point list is uniform. The weights are renormalized to sum to 1.0.
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>err = <b>initUV</b>( state, uv )</dt>
    <dd>
        Set the texture UV for a point or polygon you're about to create. If a texture map is
        selected in Modeler's interface, the UVs will be assigned to that map as points or
        polygons are created. You'll typically want to give the user the option of whether or not
        to create UVs for new points and polygons. 
        
        <p>
            When creating points, pass <tt>initUV</tt>
            an array of two floats and then call any of the functions that create a point. The two
            floats will be used as the U and V for the point, after which the <tt>initUV</tt> state
            will be cleared so that subsequent points have no UV unless the function is called again.
        </p>
        
        <p>
            To initialize per-polygon, or discontinuous, UVs, call <tt>initUV</tt> with a pointer
            to 2<em>n</em> floats before creating a polygon with <em>n</em> vertices. For each vertex,
            if the point's continuous UV value is different from the UV in the array, then a
            polygon-specific UV is set for the vertex. If the point has no continuous UV, then the
            continuous value for the point is set to the polygon UV. 
        </p>
        
        <p>
            Any combination of these two methods can be used to assign UVs to new data. If only
            polygon UVs are specified, continuous UVs will still be created where polygons share UV
            values. Alternately, plug-ins can assign UVs to points and only specify polygon UVs along
            seam polygons.
        </p>
    </dd>
</p>
  
<!-- ------------------------------------------------------------------------------- -->
<p>
  <dt>vmapID = <b>pointVSet</b>( state, vmapID, vmaptype, vmapname )</dt>
  <dd>
  Select a vmap for reading vectors. Returns an opaque pointer that can be used to select
    the same vmap in later calls to this function. The first time this is called for a given
    vmap, the pointer can be NULL, and Modeler will locate and select the vmap using the type
    and name arguments.
    </dd>
</p>
    
<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>ismapped = <b>pointVGet</b>( state, point, val )</dt>
    <dd>
        Read the vmap vector for a point. The vector is read from the vmap selected by a
        previous call to <tt>pointVSet</tt>. If the point is mapped (has a vmap value in the
        selected vmap), the <tt>val</tt> array is filled with the vmap vector for the point, and <tt>pointVGet</tt>
        returns true. If you don't already know the dimension of the vmap (the number of values
        per point, and therefore the required size of the <tt>val</tt> array), you can use the <a
        href="../globals/sceneobj.html">scene objects</a> global or use the vMapGetDimension call to find out. 
        
        <p>
            See also <tt>pointVPGet</tt> and <tt>pointVEval</tt>. <tt>pointVGet</tt> is equivalent to 
            reading values from a <a href="../filefmts/lwo2.html#c_VMAP">VMAP chunk</a> in an object file. 
            It returns the continuous, or per-point, vector. For the raw discontinuous, or per-polygon-vertex value,
            use <tt>pointVPGet</tt>, and for the combined value accounting for both sources, use <tt>pointVEval</tt>.
        </p>
    </dd>
</p>
  
<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>tag = <b>polyTag</b>( state, polygon, tagtype )</dt>
    <dd>
        Returns a tag string associated with the polygon. For the <tt>LWPTAG_SURF</tt> tag type,
        the surface name is returned.
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>
        err = <b>pntSelect</b>( state, point, setsel )<br>
        err = <b>polSelect</b>( state, polygon, setsel )
    </dt>
    <dd>
        Set the selection state of a point or polygon. These can only be called during <tt>OPSEL_MODIFY</tt>
        mesh edits. The element is selected if <tt>setsel</tt> is true and deselected if it's
        false.
    </dd>
</p>
    
<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>ismapped = <b>pointVPGet</b>( state, point, polygon, val )</dt>
    <dd>
        Read the vmap vector for a polygon vertex. This is like <tt>pointVGet</tt>, but it
        returns the discontinuous vmap value, equivalent to reading entries in a <a
        href="../filefmts/lwo2.html#c_VMAD">VMAD chunk</a>.
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>ismapped = <b>pointVEval</b>( state, point, polygon, val )</dt>
    <dd>
        Read the vmap vector for a point, accounting for both continuous and discontinuous
        values. Generally, if a discontinuous value exists for the point, that value will be
        returned.&nbsp; Otherwise the continuous value is used.
    </dd>
</p>
    
<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>err = <b>pntVPMap</b>( state, point, polygon, type, name, dim, val )</dt>
    <dd>
        Add a discontinuous vmap vector to a polygon vertex. This is the vector returned by <tt>pointVPGet</tt>.
        See <tt>pntVMap</tt> for a partial list of vmap types.
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt><b>pointPos</b>( state, point, out_position )</dt>
    <dd>
        Copies the position of the specified point into <tt>out_position</tt>. 
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt><b>pointEdges</b>( state, point, out_edges )</dt>
    <dd>
        Returns the edges surrounding the specified point.
<pre>
const LWEdgeID* edges;
int num_edges = edit->pointEdges(state, point, &edges);
// do something with edges
</pre>
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt><b>edgePolys</b>( state, edge, out_polys )</dt>
    <dd>
        Returns the polygons surrounding the specified edge.
<pre>
const LWPolID* polys;
int num_polys = edit->edgePolys(state, edge, &polys);
// do something with polys
</pre>
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt><b>polyPoints</b>( state, poly, out_points )</dt>
    <dd>
        Returns the vertices making up the specified polygon.
<pre>
const LWPntID* points;
int num_points = edit->polyPoints(state, poly, &points);
// do something with points
</pre>
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>
        p1 = <b>edgePoint1</b>( state, edge )<br>
        p2 = <b>edgePoint2</b>( state, edge )<br>
    </dt>
    <dd>
        Returns the points making up an edge.
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>
        edge = <b>edgeFromPoints</b>( state, p1, p2 )<br>
    </dt>
    <dd>
        Returns the edge between p1 and p2 if such an edge exists. Otherwise, the function
        returns NULL.
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>
        flags = <b>pointFlags</b>( state, point )<br>
        flags = <b>edgeFlags</b>( state, edge )<br>
        flags = <b>polyFlags</b>( state, polygon )
    </dt>
    <dd>
        Returns the flags associated with the specified element. These are the same values as the 
        <tt>flags</tt> fields found in the <tt>ED*Info</tt> structures.
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>
        selected_vmap = <b>vMapSelect</b>( state, vmap_name, vmap_type, vmap_dimension)<br>
    </dt>
    <dd>
        Selects a vertex map having the given name, type, and dimension.  If the vertex map does not exist, one is created.  Once a vertex map is selected, it becomes part of the state and is used in other vertex map operations.  The returned selected_vmap can be used in subsequent calls to <tt>pointVSet()</tt> to make the selection process faster.  0 (NULL) is returned if the requested vertex map could not be selected.
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>
        exists = <b>vMapExists</b>( state, vmap_name, vmap_type)<br>
    </dt>
    <dd>
        Tests is the given vertex map name and type already exists.  Returns 1 if so, else 0.
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>
        dimension = <b>vMapGetDimension</b>( state)<br>
    </dt>
    <dd>
        Obtains the dimension count of the state's current vertex map.  A value of (0) indicates no vertex map is selected.
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>
        <b>vMapSet</b>( state, point_id, polygon_id, value)<br>
    </dt>
    <dd>
        Sets a mapping of a value vector and a point (optionally a vertex of a polygon).  When a polygon_id is not specified, the mapping will be continuous (associated strictly with the vertex).  When a polygon_id is specified, the mapping will be discontinuous (associated with a vertex in a particular polygon).  An existing mapping will be overwritten with the provided value vector.  Providing a value vector of 0 (NULL) will remove the mapping.  The dimension of the value vector is assumed to be compatible with the currently selected vertex map.  To get the value vector of a particular mapping, use the <tt>pointVPGet()</tt>, <tt>pointVEval()</tt>, and <tt>pointVGet()</tt> routines. <tt>vMapSet()</tt> shares some functionality with <tt>pntVMap()</tt> and is faster because it does not need to select the vertex map for each call.  <tt>vMapSelect()</tt> must be called to select a vertex map first.
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>
        <b>vMapSetIdeal</b>( state, point_id, polygon_id, value)<br>
    </dt>
    <dd>
        Appropriately sets the 'ideal' mapping of a value vector with a point and polygon.  If the continuous mapping is not yet set, it will be set to the given value vector.  If a continuous mapping is already set and the given value vector differs from the existing one, a discontinuous mapping is added with the given value vector.  If a continuous mapping exists and its value is the same as provided, then it is overwritten and any existing discontinuous mapping is removed.
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>
        <b>vMapRename</b>( state, new_name)<br>
    </dt>
    <dd>
        Renames the state's currently selected vertex map to the provided new_name.
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <dt>
        <b>vMapRemove</b>( state)<br>
    </dt>
    <dd>
        Removes the state's currently selected vertex map.  All existing mappings are removed in the process.
    </dd>
</p>

<!-- ------------------------------------------------------------------------------- -->
</dl>

<!-- ------------------------------------------------------------------------------- -->
<p style="font: bold">Point and Polygon Info</p>
<p>
    The info and scan functions use EDPointInfo and EDPolygonInfo structures to provide
    information about points and polygons. Modeler maintains only one of each of these. It
    overwrites the structure each time data for a different point or polygon is required, so
    if you need to keep data for multiple points or polygons, you must copy it from the
    structure and store it locally. 
</p>
<pre>typedef struct st_EDPointInfo {
    LWPntID    <b>pnt</b>;
    void      *<b>userData</b>;
    int        <b>layer</b>;
    int        <b>flags</b>;
    double     <b>position</b>[3];
    float     *<b>vmapVec</b>;
} EDPointInfo;</pre>

<dl>
    <dt><b>pnt</b></dt>
    <dd>The ID of the point.</dd>
    <br><br>

    <dt><b>userData</b></dt>
    <dd>Your per-point data buffer, allocated by the MeshEditBegin call.</dd>
    <br><br>

    <dt><b>layer</b></dt>
    <dd>The layer in which the point resides.</dd>
    <br><br>

    <dt><b>flags</b></dt>
    <dd>Flags for the point. The <tt>EDDF_SELECT</tt> bit is set if the selection state of the
    point matches the EltOpSelect passed to the MeshEditBegin function. The <tt>EDDF_DELETE</tt>
    bit is set if the point has been deleted during this mesh edit.</dd>
    <br><br>

    <dt><b>position</b></dt>
    <dd>The point's position.</dd>
    <br><br>

    <dt><b>vmapVec</b></dt>
    <dd>The vmap values associated with the point.</dd>
</dl>

<pre>typedef struct st_EDPolygonInfo
{
    LWPolID        <b>pol</b>;
    void          *<b>userData</b>;
    int            <b>layer</b>;
    int            <b>flags</b>;
    int            <b>numPnts</b>;
    const LWPntID *<b>points</b>;
    const char    *<b>surface</b>;
    unsigned int   <b>type</b>;
    int            <b>typeFlags</b>;
} EDPolygonInfo;</pre>

<dl>
    <dt><b>pol</b></dt>
    <dd>The polygon ID.</dd>
    <br><br>

    <dt><b>userData</b></dt>
    <dd>Your per-polygon data buffer, allocated by the MeshEditBegin call.</dd>
    <br><br>

    <dt><b>layer</b></dt>
    <dd>The layer in which the polygon resides.</dd>
    <br><br>

    <dt><b>flags</b></dt>
    <dd>Flags for the polygon. These include the <tt>EDPF_CCSTART</tt> and <tt>EDDF_CCEND</tt>
    bits for curves.</dd>
    <br><br>

    <dt><b>numPnts</b></dt>
    <dd>The number of vertices in the polygon.</dd>
    <br><br>

    <dt><b>points</b></dt>
    <dd>An array of point IDs for the vertices of the polygon.</dd>
    <br><br>

    <dt><b>surface</b></dt>
    <dd>The polygon's surface.</dd>
    <br><br>

    <dt><b>type</b></dt>
    <dd>
        The polygon type, which will usually be one of the following. 
        <p>
            <tt>LWPOLTYPE_FACE</tt> - face<br>
            <tt>LWPOLTYPE_CURV</tt> - higher order curve<br>
            <tt>LWPOLTYPE_PTCH</tt> - subdivision control cage polygon<br>
            <tt>LWPOLTYPE_MBAL</tt> - metaball<br>
            <tt>LWPOLTYPE_BONE</tt> - bone
        </p>
        Note that the number of polygon types may be expanded by plugins or
        future versions of LightWave&reg;. Do not limit functionality to
        particular polygon types, unless there is a very good reason to. The
        <b>typeFlags</b> value is usually a better indicator of what the
        polygon can be used for.
    </dd>
    <br><br>

    <dt><b>typeFlags</b></dt>
    <dd>
        The flags for the polygon type. These are the <tt>LWGPTF_*</tt> flags
        for the polygon type as defined in <a href="../../include/lwpolygon.h">lwpolygon.h</a>
    </dd>
    <br><br>
</dl>

<!-- ------------------------------------------------------------------------------- -->
<p>
    <b>Example</b>
</p>
<p>
    The <a href="../../sample/Modeler/CommandSequence/zfacing/">zfacing</a> sample demonstrates <tt>OPSEL_MODIFY</tt>
    edits. This method of altering the selection is especially useful in <a href="cs.html">CommandSequence</a>
    plug-ins, so <tt>zfacing.c</tt> contains both edit and command versions of the activation
    function. The <a href="../../sample/Modeler/Input-Output/vidscape/">vidscape</a> sample uses mesh editing to
    enumerate the geometry of an object before exporting it to a VideoScape format file. Many
    former mesh edit sample plug-ins, notably <a href="../../sample/Modeler/MeshEdit/superq/">superq</a> and 
    <a href="../../sample/Modeler/MeshEdit/spikeytool/">spikey</a>, have been converted to interactive mesh edit 
    <a href="metool.html">tools</a>.
</p>

<!-- ******************************************************************************* -->
</td></tr></table>

</body>
</html>
